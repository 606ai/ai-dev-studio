
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>
/**
 * Model ModelCollaborator
 * 
 */
export type ModelCollaborator = $Result.DefaultSelection<Prisma.$ModelCollaboratorPayload>
/**
 * Model ModelVersion
 * 
 */
export type ModelVersion = $Result.DefaultSelection<Prisma.$ModelVersionPayload>
/**
 * Model Change
 * 
 */
export type Change = $Result.DefaultSelection<Prisma.$ChangePayload>
/**
 * Model ChangeReviewer
 * 
 */
export type ChangeReviewer = $Result.DefaultSelection<Prisma.$ChangeReviewerPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CommentReaction
 * 
 */
export type CommentReaction = $Result.DefaultSelection<Prisma.$CommentReactionPayload>
/**
 * Model Deployment
 * 
 */
export type Deployment = $Result.DefaultSelection<Prisma.$DeploymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ModelStatus: {
  DRAFT: 'DRAFT',
  TRAINING: 'TRAINING',
  READY: 'READY',
  DEPLOYED: 'DEPLOYED',
  ARCHIVED: 'ARCHIVED'
};

export type ModelStatus = (typeof ModelStatus)[keyof typeof ModelStatus]


export const CollaboratorRole: {
  OWNER: 'OWNER',
  EDITOR: 'EDITOR',
  VIEWER: 'VIEWER'
};

export type CollaboratorRole = (typeof CollaboratorRole)[keyof typeof CollaboratorRole]


export const VersionStatus: {
  CREATED: 'CREATED',
  TRAINING: 'TRAINING',
  READY: 'READY',
  FAILED: 'FAILED'
};

export type VersionStatus = (typeof VersionStatus)[keyof typeof VersionStatus]


export const ChangeType: {
  ADD: 'ADD',
  MODIFY: 'MODIFY',
  DELETE: 'DELETE'
};

export type ChangeType = (typeof ChangeType)[keyof typeof ChangeType]


export const ChangeStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ChangeStatus = (typeof ChangeStatus)[keyof typeof ChangeStatus]


export const ReviewStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const DeploymentStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  FAILED: 'FAILED',
  STOPPED: 'STOPPED'
};

export type DeploymentStatus = (typeof DeploymentStatus)[keyof typeof DeploymentStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ModelStatus = $Enums.ModelStatus

export const ModelStatus: typeof $Enums.ModelStatus

export type CollaboratorRole = $Enums.CollaboratorRole

export const CollaboratorRole: typeof $Enums.CollaboratorRole

export type VersionStatus = $Enums.VersionStatus

export const VersionStatus: typeof $Enums.VersionStatus

export type ChangeType = $Enums.ChangeType

export const ChangeType: typeof $Enums.ChangeType

export type ChangeStatus = $Enums.ChangeStatus

export const ChangeStatus: typeof $Enums.ChangeStatus

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type DeploymentStatus = $Enums.DeploymentStatus

export const DeploymentStatus: typeof $Enums.DeploymentStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs>;

  /**
   * `prisma.modelCollaborator`: Exposes CRUD operations for the **ModelCollaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelCollaborators
    * const modelCollaborators = await prisma.modelCollaborator.findMany()
    * ```
    */
  get modelCollaborator(): Prisma.ModelCollaboratorDelegate<ExtArgs>;

  /**
   * `prisma.modelVersion`: Exposes CRUD operations for the **ModelVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelVersions
    * const modelVersions = await prisma.modelVersion.findMany()
    * ```
    */
  get modelVersion(): Prisma.ModelVersionDelegate<ExtArgs>;

  /**
   * `prisma.change`: Exposes CRUD operations for the **Change** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Changes
    * const changes = await prisma.change.findMany()
    * ```
    */
  get change(): Prisma.ChangeDelegate<ExtArgs>;

  /**
   * `prisma.changeReviewer`: Exposes CRUD operations for the **ChangeReviewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeReviewers
    * const changeReviewers = await prisma.changeReviewer.findMany()
    * ```
    */
  get changeReviewer(): Prisma.ChangeReviewerDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.commentReaction`: Exposes CRUD operations for the **CommentReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentReactions
    * const commentReactions = await prisma.commentReaction.findMany()
    * ```
    */
  get commentReaction(): Prisma.CommentReactionDelegate<ExtArgs>;

  /**
   * `prisma.deployment`: Exposes CRUD operations for the **Deployment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deployments
    * const deployments = await prisma.deployment.findMany()
    * ```
    */
  get deployment(): Prisma.DeploymentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Model: 'Model',
    ModelCollaborator: 'ModelCollaborator',
    ModelVersion: 'ModelVersion',
    Change: 'Change',
    ChangeReviewer: 'ChangeReviewer',
    Comment: 'Comment',
    CommentReaction: 'CommentReaction',
    Deployment: 'Deployment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "model" | "modelCollaborator" | "modelVersion" | "change" | "changeReviewer" | "comment" | "commentReaction" | "deployment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
      ModelCollaborator: {
        payload: Prisma.$ModelCollaboratorPayload<ExtArgs>
        fields: Prisma.ModelCollaboratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelCollaboratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelCollaboratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>
          }
          findFirst: {
            args: Prisma.ModelCollaboratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelCollaboratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>
          }
          findMany: {
            args: Prisma.ModelCollaboratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>[]
          }
          create: {
            args: Prisma.ModelCollaboratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>
          }
          createMany: {
            args: Prisma.ModelCollaboratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelCollaboratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>[]
          }
          delete: {
            args: Prisma.ModelCollaboratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>
          }
          update: {
            args: Prisma.ModelCollaboratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.ModelCollaboratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelCollaboratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelCollaboratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelCollaboratorPayload>
          }
          aggregate: {
            args: Prisma.ModelCollaboratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelCollaborator>
          }
          groupBy: {
            args: Prisma.ModelCollaboratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelCollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelCollaboratorCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCollaboratorCountAggregateOutputType> | number
          }
        }
      }
      ModelVersion: {
        payload: Prisma.$ModelVersionPayload<ExtArgs>
        fields: Prisma.ModelVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>
          }
          findFirst: {
            args: Prisma.ModelVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>
          }
          findMany: {
            args: Prisma.ModelVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>[]
          }
          create: {
            args: Prisma.ModelVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>
          }
          createMany: {
            args: Prisma.ModelVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>[]
          }
          delete: {
            args: Prisma.ModelVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>
          }
          update: {
            args: Prisma.ModelVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>
          }
          deleteMany: {
            args: Prisma.ModelVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModelVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelVersionPayload>
          }
          aggregate: {
            args: Prisma.ModelVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelVersion>
          }
          groupBy: {
            args: Prisma.ModelVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ModelVersionCountAggregateOutputType> | number
          }
        }
      }
      Change: {
        payload: Prisma.$ChangePayload<ExtArgs>
        fields: Prisma.ChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>
          }
          findFirst: {
            args: Prisma.ChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>
          }
          findMany: {
            args: Prisma.ChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>[]
          }
          create: {
            args: Prisma.ChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>
          }
          createMany: {
            args: Prisma.ChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>[]
          }
          delete: {
            args: Prisma.ChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>
          }
          update: {
            args: Prisma.ChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>
          }
          deleteMany: {
            args: Prisma.ChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangePayload>
          }
          aggregate: {
            args: Prisma.ChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChange>
          }
          groupBy: {
            args: Prisma.ChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeCountAggregateOutputType> | number
          }
        }
      }
      ChangeReviewer: {
        payload: Prisma.$ChangeReviewerPayload<ExtArgs>
        fields: Prisma.ChangeReviewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeReviewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeReviewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>
          }
          findFirst: {
            args: Prisma.ChangeReviewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeReviewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>
          }
          findMany: {
            args: Prisma.ChangeReviewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>[]
          }
          create: {
            args: Prisma.ChangeReviewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>
          }
          createMany: {
            args: Prisma.ChangeReviewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeReviewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>[]
          }
          delete: {
            args: Prisma.ChangeReviewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>
          }
          update: {
            args: Prisma.ChangeReviewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>
          }
          deleteMany: {
            args: Prisma.ChangeReviewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeReviewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChangeReviewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeReviewerPayload>
          }
          aggregate: {
            args: Prisma.ChangeReviewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeReviewer>
          }
          groupBy: {
            args: Prisma.ChangeReviewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeReviewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeReviewerCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeReviewerCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommentReaction: {
        payload: Prisma.$CommentReactionPayload<ExtArgs>
        fields: Prisma.CommentReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          findFirst: {
            args: Prisma.CommentReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          findMany: {
            args: Prisma.CommentReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          create: {
            args: Prisma.CommentReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          createMany: {
            args: Prisma.CommentReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          delete: {
            args: Prisma.CommentReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          update: {
            args: Prisma.CommentReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          deleteMany: {
            args: Prisma.CommentReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          aggregate: {
            args: Prisma.CommentReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentReaction>
          }
          groupBy: {
            args: Prisma.CommentReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentReactionCountArgs<ExtArgs>
            result: $Utils.Optional<CommentReactionCountAggregateOutputType> | number
          }
        }
      }
      Deployment: {
        payload: Prisma.$DeploymentPayload<ExtArgs>
        fields: Prisma.DeploymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeploymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeploymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          findFirst: {
            args: Prisma.DeploymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeploymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          findMany: {
            args: Prisma.DeploymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>[]
          }
          create: {
            args: Prisma.DeploymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          createMany: {
            args: Prisma.DeploymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeploymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>[]
          }
          delete: {
            args: Prisma.DeploymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          update: {
            args: Prisma.DeploymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          deleteMany: {
            args: Prisma.DeploymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeploymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeploymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          aggregate: {
            args: Prisma.DeploymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeployment>
          }
          groupBy: {
            args: Prisma.DeploymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeploymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeploymentCountArgs<ExtArgs>
            result: $Utils.Optional<DeploymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    models: number
    collaborations: number
    changes: number
    comments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | UserCountOutputTypeCountModelsArgs
    collaborations?: boolean | UserCountOutputTypeCountCollaborationsArgs
    changes?: boolean | UserCountOutputTypeCountChangesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelCollaboratorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ModelCountOutputType
   */

  export type ModelCountOutputType = {
    collaborators: number
    versions: number
    changes: number
    deployments: number
  }

  export type ModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collaborators?: boolean | ModelCountOutputTypeCountCollaboratorsArgs
    versions?: boolean | ModelCountOutputTypeCountVersionsArgs
    changes?: boolean | ModelCountOutputTypeCountChangesArgs
    deployments?: boolean | ModelCountOutputTypeCountDeploymentsArgs
  }

  // Custom InputTypes
  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelCollaboratorWhereInput
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelVersionWhereInput
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeWhereInput
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
  }


  /**
   * Count Type ModelVersionCountOutputType
   */

  export type ModelVersionCountOutputType = {
    deployments: number
  }

  export type ModelVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deployments?: boolean | ModelVersionCountOutputTypeCountDeploymentsArgs
  }

  // Custom InputTypes
  /**
   * ModelVersionCountOutputType without action
   */
  export type ModelVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersionCountOutputType
     */
    select?: ModelVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelVersionCountOutputType without action
   */
  export type ModelVersionCountOutputTypeCountDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
  }


  /**
   * Count Type ChangeCountOutputType
   */

  export type ChangeCountOutputType = {
    comments: number
    reviewers: number
  }

  export type ChangeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ChangeCountOutputTypeCountCommentsArgs
    reviewers?: boolean | ChangeCountOutputTypeCountReviewersArgs
  }

  // Custom InputTypes
  /**
   * ChangeCountOutputType without action
   */
  export type ChangeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeCountOutputType
     */
    select?: ChangeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChangeCountOutputType without action
   */
  export type ChangeCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ChangeCountOutputType without action
   */
  export type ChangeCountOutputTypeCountReviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeReviewerWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    reactions: number
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactions?: boolean | CommentCountOutputTypeCountReactionsArgs
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    avatar: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    passwordHash: string
    avatar: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    models?: boolean | User$modelsArgs<ExtArgs>
    collaborations?: boolean | User$collaborationsArgs<ExtArgs>
    changes?: boolean | User$changesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | User$modelsArgs<ExtArgs>
    collaborations?: boolean | User$collaborationsArgs<ExtArgs>
    changes?: boolean | User$changesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      models: Prisma.$ModelPayload<ExtArgs>[]
      collaborations: Prisma.$ModelCollaboratorPayload<ExtArgs>[]
      changes: Prisma.$ChangePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      passwordHash: string
      avatar: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends User$modelsArgs<ExtArgs> = {}>(args?: Subset<T, User$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany"> | Null>
    collaborations<T extends User$collaborationsArgs<ExtArgs> = {}>(args?: Subset<T, User$collaborationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "findMany"> | Null>
    changes<T extends User$changesArgs<ExtArgs> = {}>(args?: Subset<T, User$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.models
   */
  export type User$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * User.collaborations
   */
  export type User$collaborationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    where?: ModelCollaboratorWhereInput
    orderBy?: ModelCollaboratorOrderByWithRelationInput | ModelCollaboratorOrderByWithRelationInput[]
    cursor?: ModelCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelCollaboratorScalarFieldEnum | ModelCollaboratorScalarFieldEnum[]
  }

  /**
   * User.changes
   */
  export type User$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    where?: ChangeWhereInput
    orderBy?: ChangeOrderByWithRelationInput | ChangeOrderByWithRelationInput[]
    cursor?: ChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeScalarFieldEnum | ChangeScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    status: $Enums.ModelStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    status: $Enums.ModelStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ownerId: string
    status: $Enums.ModelStatus
    createdAt: Date
    updatedAt: Date
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    collaborators?: boolean | Model$collaboratorsArgs<ExtArgs>
    versions?: boolean | Model$versionsArgs<ExtArgs>
    changes?: boolean | Model$changesArgs<ExtArgs>
    deployments?: boolean | Model$deploymentsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    collaborators?: boolean | Model$collaboratorsArgs<ExtArgs>
    versions?: boolean | Model$versionsArgs<ExtArgs>
    changes?: boolean | Model$changesArgs<ExtArgs>
    deployments?: boolean | Model$deploymentsArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      collaborators: Prisma.$ModelCollaboratorPayload<ExtArgs>[]
      versions: Prisma.$ModelVersionPayload<ExtArgs>[]
      changes: Prisma.$ChangePayload<ExtArgs>[]
      deployments: Prisma.$DeploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      ownerId: string
      status: $Enums.ModelStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Models and returns the data saved in the database.
     * @param {ModelCreateManyAndReturnArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Models and only return the `id`
     * const modelWithIdOnly = await prisma.model.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    collaborators<T extends Model$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, Model$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "findMany"> | Null>
    versions<T extends Model$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Model$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "findMany"> | Null>
    changes<T extends Model$changesArgs<ExtArgs> = {}>(args?: Subset<T, Model$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findMany"> | Null>
    deployments<T extends Model$deploymentsArgs<ExtArgs> = {}>(args?: Subset<T, Model$deploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */ 
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'String'>
    readonly name: FieldRef<"Model", 'String'>
    readonly description: FieldRef<"Model", 'String'>
    readonly ownerId: FieldRef<"Model", 'String'>
    readonly status: FieldRef<"Model", 'ModelStatus'>
    readonly createdAt: FieldRef<"Model", 'DateTime'>
    readonly updatedAt: FieldRef<"Model", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Model createManyAndReturn
   */
  export type ModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
  }

  /**
   * Model.collaborators
   */
  export type Model$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    where?: ModelCollaboratorWhereInput
    orderBy?: ModelCollaboratorOrderByWithRelationInput | ModelCollaboratorOrderByWithRelationInput[]
    cursor?: ModelCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelCollaboratorScalarFieldEnum | ModelCollaboratorScalarFieldEnum[]
  }

  /**
   * Model.versions
   */
  export type Model$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    where?: ModelVersionWhereInput
    orderBy?: ModelVersionOrderByWithRelationInput | ModelVersionOrderByWithRelationInput[]
    cursor?: ModelVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelVersionScalarFieldEnum | ModelVersionScalarFieldEnum[]
  }

  /**
   * Model.changes
   */
  export type Model$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    where?: ChangeWhereInput
    orderBy?: ChangeOrderByWithRelationInput | ChangeOrderByWithRelationInput[]
    cursor?: ChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeScalarFieldEnum | ChangeScalarFieldEnum[]
  }

  /**
   * Model.deployments
   */
  export type Model$deploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    cursor?: DeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Model ModelCollaborator
   */

  export type AggregateModelCollaborator = {
    _count: ModelCollaboratorCountAggregateOutputType | null
    _min: ModelCollaboratorMinAggregateOutputType | null
    _max: ModelCollaboratorMaxAggregateOutputType | null
  }

  export type ModelCollaboratorMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    userId: string | null
    role: $Enums.CollaboratorRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelCollaboratorMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    userId: string | null
    role: $Enums.CollaboratorRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelCollaboratorCountAggregateOutputType = {
    id: number
    modelId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelCollaboratorMinAggregateInputType = {
    id?: true
    modelId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelCollaboratorMaxAggregateInputType = {
    id?: true
    modelId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelCollaboratorCountAggregateInputType = {
    id?: true
    modelId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelCollaboratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelCollaborator to aggregate.
     */
    where?: ModelCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelCollaborators to fetch.
     */
    orderBy?: ModelCollaboratorOrderByWithRelationInput | ModelCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelCollaborators
    **/
    _count?: true | ModelCollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelCollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelCollaboratorMaxAggregateInputType
  }

  export type GetModelCollaboratorAggregateType<T extends ModelCollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateModelCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelCollaborator[P]>
      : GetScalarType<T[P], AggregateModelCollaborator[P]>
  }




  export type ModelCollaboratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelCollaboratorWhereInput
    orderBy?: ModelCollaboratorOrderByWithAggregationInput | ModelCollaboratorOrderByWithAggregationInput[]
    by: ModelCollaboratorScalarFieldEnum[] | ModelCollaboratorScalarFieldEnum
    having?: ModelCollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCollaboratorCountAggregateInputType | true
    _min?: ModelCollaboratorMinAggregateInputType
    _max?: ModelCollaboratorMaxAggregateInputType
  }

  export type ModelCollaboratorGroupByOutputType = {
    id: string
    modelId: string
    userId: string
    role: $Enums.CollaboratorRole
    createdAt: Date
    updatedAt: Date
    _count: ModelCollaboratorCountAggregateOutputType | null
    _min: ModelCollaboratorMinAggregateOutputType | null
    _max: ModelCollaboratorMaxAggregateOutputType | null
  }

  type GetModelCollaboratorGroupByPayload<T extends ModelCollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelCollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelCollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelCollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], ModelCollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type ModelCollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelCollaborator"]>

  export type ModelCollaboratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelCollaborator"]>

  export type ModelCollaboratorSelectScalar = {
    id?: boolean
    modelId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelCollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ModelCollaboratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ModelCollaboratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelCollaborator"
    objects: {
      model: Prisma.$ModelPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      userId: string
      role: $Enums.CollaboratorRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modelCollaborator"]>
    composites: {}
  }

  type ModelCollaboratorGetPayload<S extends boolean | null | undefined | ModelCollaboratorDefaultArgs> = $Result.GetResult<Prisma.$ModelCollaboratorPayload, S>

  type ModelCollaboratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModelCollaboratorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModelCollaboratorCountAggregateInputType | true
    }

  export interface ModelCollaboratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelCollaborator'], meta: { name: 'ModelCollaborator' } }
    /**
     * Find zero or one ModelCollaborator that matches the filter.
     * @param {ModelCollaboratorFindUniqueArgs} args - Arguments to find a ModelCollaborator
     * @example
     * // Get one ModelCollaborator
     * const modelCollaborator = await prisma.modelCollaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelCollaboratorFindUniqueArgs>(args: SelectSubset<T, ModelCollaboratorFindUniqueArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModelCollaborator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModelCollaboratorFindUniqueOrThrowArgs} args - Arguments to find a ModelCollaborator
     * @example
     * // Get one ModelCollaborator
     * const modelCollaborator = await prisma.modelCollaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelCollaboratorFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelCollaboratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModelCollaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCollaboratorFindFirstArgs} args - Arguments to find a ModelCollaborator
     * @example
     * // Get one ModelCollaborator
     * const modelCollaborator = await prisma.modelCollaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelCollaboratorFindFirstArgs>(args?: SelectSubset<T, ModelCollaboratorFindFirstArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModelCollaborator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCollaboratorFindFirstOrThrowArgs} args - Arguments to find a ModelCollaborator
     * @example
     * // Get one ModelCollaborator
     * const modelCollaborator = await prisma.modelCollaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelCollaboratorFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelCollaboratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModelCollaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCollaboratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelCollaborators
     * const modelCollaborators = await prisma.modelCollaborator.findMany()
     * 
     * // Get first 10 ModelCollaborators
     * const modelCollaborators = await prisma.modelCollaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelCollaboratorWithIdOnly = await prisma.modelCollaborator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelCollaboratorFindManyArgs>(args?: SelectSubset<T, ModelCollaboratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModelCollaborator.
     * @param {ModelCollaboratorCreateArgs} args - Arguments to create a ModelCollaborator.
     * @example
     * // Create one ModelCollaborator
     * const ModelCollaborator = await prisma.modelCollaborator.create({
     *   data: {
     *     // ... data to create a ModelCollaborator
     *   }
     * })
     * 
     */
    create<T extends ModelCollaboratorCreateArgs>(args: SelectSubset<T, ModelCollaboratorCreateArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModelCollaborators.
     * @param {ModelCollaboratorCreateManyArgs} args - Arguments to create many ModelCollaborators.
     * @example
     * // Create many ModelCollaborators
     * const modelCollaborator = await prisma.modelCollaborator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCollaboratorCreateManyArgs>(args?: SelectSubset<T, ModelCollaboratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelCollaborators and returns the data saved in the database.
     * @param {ModelCollaboratorCreateManyAndReturnArgs} args - Arguments to create many ModelCollaborators.
     * @example
     * // Create many ModelCollaborators
     * const modelCollaborator = await prisma.modelCollaborator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelCollaborators and only return the `id`
     * const modelCollaboratorWithIdOnly = await prisma.modelCollaborator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelCollaboratorCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelCollaboratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModelCollaborator.
     * @param {ModelCollaboratorDeleteArgs} args - Arguments to delete one ModelCollaborator.
     * @example
     * // Delete one ModelCollaborator
     * const ModelCollaborator = await prisma.modelCollaborator.delete({
     *   where: {
     *     // ... filter to delete one ModelCollaborator
     *   }
     * })
     * 
     */
    delete<T extends ModelCollaboratorDeleteArgs>(args: SelectSubset<T, ModelCollaboratorDeleteArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModelCollaborator.
     * @param {ModelCollaboratorUpdateArgs} args - Arguments to update one ModelCollaborator.
     * @example
     * // Update one ModelCollaborator
     * const modelCollaborator = await prisma.modelCollaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelCollaboratorUpdateArgs>(args: SelectSubset<T, ModelCollaboratorUpdateArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModelCollaborators.
     * @param {ModelCollaboratorDeleteManyArgs} args - Arguments to filter ModelCollaborators to delete.
     * @example
     * // Delete a few ModelCollaborators
     * const { count } = await prisma.modelCollaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelCollaboratorDeleteManyArgs>(args?: SelectSubset<T, ModelCollaboratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelCollaborators
     * const modelCollaborator = await prisma.modelCollaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelCollaboratorUpdateManyArgs>(args: SelectSubset<T, ModelCollaboratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModelCollaborator.
     * @param {ModelCollaboratorUpsertArgs} args - Arguments to update or create a ModelCollaborator.
     * @example
     * // Update or create a ModelCollaborator
     * const modelCollaborator = await prisma.modelCollaborator.upsert({
     *   create: {
     *     // ... data to create a ModelCollaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelCollaborator we want to update
     *   }
     * })
     */
    upsert<T extends ModelCollaboratorUpsertArgs>(args: SelectSubset<T, ModelCollaboratorUpsertArgs<ExtArgs>>): Prisma__ModelCollaboratorClient<$Result.GetResult<Prisma.$ModelCollaboratorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModelCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCollaboratorCountArgs} args - Arguments to filter ModelCollaborators to count.
     * @example
     * // Count the number of ModelCollaborators
     * const count = await prisma.modelCollaborator.count({
     *   where: {
     *     // ... the filter for the ModelCollaborators we want to count
     *   }
     * })
    **/
    count<T extends ModelCollaboratorCountArgs>(
      args?: Subset<T, ModelCollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelCollaboratorAggregateArgs>(args: Subset<T, ModelCollaboratorAggregateArgs>): Prisma.PrismaPromise<GetModelCollaboratorAggregateType<T>>

    /**
     * Group by ModelCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelCollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelCollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: ModelCollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelCollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelCollaborator model
   */
  readonly fields: ModelCollaboratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelCollaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelCollaboratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelCollaborator model
   */ 
  interface ModelCollaboratorFieldRefs {
    readonly id: FieldRef<"ModelCollaborator", 'String'>
    readonly modelId: FieldRef<"ModelCollaborator", 'String'>
    readonly userId: FieldRef<"ModelCollaborator", 'String'>
    readonly role: FieldRef<"ModelCollaborator", 'CollaboratorRole'>
    readonly createdAt: FieldRef<"ModelCollaborator", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelCollaborator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelCollaborator findUnique
   */
  export type ModelCollaboratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ModelCollaborator to fetch.
     */
    where: ModelCollaboratorWhereUniqueInput
  }

  /**
   * ModelCollaborator findUniqueOrThrow
   */
  export type ModelCollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ModelCollaborator to fetch.
     */
    where: ModelCollaboratorWhereUniqueInput
  }

  /**
   * ModelCollaborator findFirst
   */
  export type ModelCollaboratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ModelCollaborator to fetch.
     */
    where?: ModelCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelCollaborators to fetch.
     */
    orderBy?: ModelCollaboratorOrderByWithRelationInput | ModelCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelCollaborators.
     */
    cursor?: ModelCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelCollaborators.
     */
    distinct?: ModelCollaboratorScalarFieldEnum | ModelCollaboratorScalarFieldEnum[]
  }

  /**
   * ModelCollaborator findFirstOrThrow
   */
  export type ModelCollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ModelCollaborator to fetch.
     */
    where?: ModelCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelCollaborators to fetch.
     */
    orderBy?: ModelCollaboratorOrderByWithRelationInput | ModelCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelCollaborators.
     */
    cursor?: ModelCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelCollaborators.
     */
    distinct?: ModelCollaboratorScalarFieldEnum | ModelCollaboratorScalarFieldEnum[]
  }

  /**
   * ModelCollaborator findMany
   */
  export type ModelCollaboratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ModelCollaborators to fetch.
     */
    where?: ModelCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelCollaborators to fetch.
     */
    orderBy?: ModelCollaboratorOrderByWithRelationInput | ModelCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelCollaborators.
     */
    cursor?: ModelCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelCollaborators.
     */
    skip?: number
    distinct?: ModelCollaboratorScalarFieldEnum | ModelCollaboratorScalarFieldEnum[]
  }

  /**
   * ModelCollaborator create
   */
  export type ModelCollaboratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelCollaborator.
     */
    data: XOR<ModelCollaboratorCreateInput, ModelCollaboratorUncheckedCreateInput>
  }

  /**
   * ModelCollaborator createMany
   */
  export type ModelCollaboratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelCollaborators.
     */
    data: ModelCollaboratorCreateManyInput | ModelCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelCollaborator createManyAndReturn
   */
  export type ModelCollaboratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModelCollaborators.
     */
    data: ModelCollaboratorCreateManyInput | ModelCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModelCollaborator update
   */
  export type ModelCollaboratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelCollaborator.
     */
    data: XOR<ModelCollaboratorUpdateInput, ModelCollaboratorUncheckedUpdateInput>
    /**
     * Choose, which ModelCollaborator to update.
     */
    where: ModelCollaboratorWhereUniqueInput
  }

  /**
   * ModelCollaborator updateMany
   */
  export type ModelCollaboratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelCollaborators.
     */
    data: XOR<ModelCollaboratorUpdateManyMutationInput, ModelCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which ModelCollaborators to update
     */
    where?: ModelCollaboratorWhereInput
  }

  /**
   * ModelCollaborator upsert
   */
  export type ModelCollaboratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelCollaborator to update in case it exists.
     */
    where: ModelCollaboratorWhereUniqueInput
    /**
     * In case the ModelCollaborator found by the `where` argument doesn't exist, create a new ModelCollaborator with this data.
     */
    create: XOR<ModelCollaboratorCreateInput, ModelCollaboratorUncheckedCreateInput>
    /**
     * In case the ModelCollaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelCollaboratorUpdateInput, ModelCollaboratorUncheckedUpdateInput>
  }

  /**
   * ModelCollaborator delete
   */
  export type ModelCollaboratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
    /**
     * Filter which ModelCollaborator to delete.
     */
    where: ModelCollaboratorWhereUniqueInput
  }

  /**
   * ModelCollaborator deleteMany
   */
  export type ModelCollaboratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelCollaborators to delete
     */
    where?: ModelCollaboratorWhereInput
  }

  /**
   * ModelCollaborator without action
   */
  export type ModelCollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCollaborator
     */
    select?: ModelCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelCollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model ModelVersion
   */

  export type AggregateModelVersion = {
    _count: ModelVersionCountAggregateOutputType | null
    _min: ModelVersionMinAggregateOutputType | null
    _max: ModelVersionMaxAggregateOutputType | null
  }

  export type ModelVersionMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    version: string | null
    status: $Enums.VersionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelVersionMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    version: string | null
    status: $Enums.VersionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelVersionCountAggregateOutputType = {
    id: number
    modelId: number
    version: number
    metrics: number
    artifacts: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelVersionMinAggregateInputType = {
    id?: true
    modelId?: true
    version?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelVersionMaxAggregateInputType = {
    id?: true
    modelId?: true
    version?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelVersionCountAggregateInputType = {
    id?: true
    modelId?: true
    version?: true
    metrics?: true
    artifacts?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelVersion to aggregate.
     */
    where?: ModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelVersions to fetch.
     */
    orderBy?: ModelVersionOrderByWithRelationInput | ModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelVersions
    **/
    _count?: true | ModelVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelVersionMaxAggregateInputType
  }

  export type GetModelVersionAggregateType<T extends ModelVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateModelVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelVersion[P]>
      : GetScalarType<T[P], AggregateModelVersion[P]>
  }




  export type ModelVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelVersionWhereInput
    orderBy?: ModelVersionOrderByWithAggregationInput | ModelVersionOrderByWithAggregationInput[]
    by: ModelVersionScalarFieldEnum[] | ModelVersionScalarFieldEnum
    having?: ModelVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelVersionCountAggregateInputType | true
    _min?: ModelVersionMinAggregateInputType
    _max?: ModelVersionMaxAggregateInputType
  }

  export type ModelVersionGroupByOutputType = {
    id: string
    modelId: string
    version: string
    metrics: JsonValue | null
    artifacts: JsonValue
    status: $Enums.VersionStatus
    createdAt: Date
    updatedAt: Date
    _count: ModelVersionCountAggregateOutputType | null
    _min: ModelVersionMinAggregateOutputType | null
    _max: ModelVersionMaxAggregateOutputType | null
  }

  type GetModelVersionGroupByPayload<T extends ModelVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ModelVersionGroupByOutputType[P]>
        }
      >
    >


  export type ModelVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    version?: boolean
    metrics?: boolean
    artifacts?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    deployments?: boolean | ModelVersion$deploymentsArgs<ExtArgs>
    _count?: boolean | ModelVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelVersion"]>

  export type ModelVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    version?: boolean
    metrics?: boolean
    artifacts?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelVersion"]>

  export type ModelVersionSelectScalar = {
    id?: boolean
    modelId?: boolean
    version?: boolean
    metrics?: boolean
    artifacts?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    deployments?: boolean | ModelVersion$deploymentsArgs<ExtArgs>
    _count?: boolean | ModelVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModelVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }

  export type $ModelVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelVersion"
    objects: {
      model: Prisma.$ModelPayload<ExtArgs>
      deployments: Prisma.$DeploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      version: string
      metrics: Prisma.JsonValue | null
      artifacts: Prisma.JsonValue
      status: $Enums.VersionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modelVersion"]>
    composites: {}
  }

  type ModelVersionGetPayload<S extends boolean | null | undefined | ModelVersionDefaultArgs> = $Result.GetResult<Prisma.$ModelVersionPayload, S>

  type ModelVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModelVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModelVersionCountAggregateInputType | true
    }

  export interface ModelVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelVersion'], meta: { name: 'ModelVersion' } }
    /**
     * Find zero or one ModelVersion that matches the filter.
     * @param {ModelVersionFindUniqueArgs} args - Arguments to find a ModelVersion
     * @example
     * // Get one ModelVersion
     * const modelVersion = await prisma.modelVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelVersionFindUniqueArgs>(args: SelectSubset<T, ModelVersionFindUniqueArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModelVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModelVersionFindUniqueOrThrowArgs} args - Arguments to find a ModelVersion
     * @example
     * // Get one ModelVersion
     * const modelVersion = await prisma.modelVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModelVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelVersionFindFirstArgs} args - Arguments to find a ModelVersion
     * @example
     * // Get one ModelVersion
     * const modelVersion = await prisma.modelVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelVersionFindFirstArgs>(args?: SelectSubset<T, ModelVersionFindFirstArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModelVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelVersionFindFirstOrThrowArgs} args - Arguments to find a ModelVersion
     * @example
     * // Get one ModelVersion
     * const modelVersion = await prisma.modelVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModelVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelVersions
     * const modelVersions = await prisma.modelVersion.findMany()
     * 
     * // Get first 10 ModelVersions
     * const modelVersions = await prisma.modelVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelVersionWithIdOnly = await prisma.modelVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelVersionFindManyArgs>(args?: SelectSubset<T, ModelVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModelVersion.
     * @param {ModelVersionCreateArgs} args - Arguments to create a ModelVersion.
     * @example
     * // Create one ModelVersion
     * const ModelVersion = await prisma.modelVersion.create({
     *   data: {
     *     // ... data to create a ModelVersion
     *   }
     * })
     * 
     */
    create<T extends ModelVersionCreateArgs>(args: SelectSubset<T, ModelVersionCreateArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModelVersions.
     * @param {ModelVersionCreateManyArgs} args - Arguments to create many ModelVersions.
     * @example
     * // Create many ModelVersions
     * const modelVersion = await prisma.modelVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelVersionCreateManyArgs>(args?: SelectSubset<T, ModelVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelVersions and returns the data saved in the database.
     * @param {ModelVersionCreateManyAndReturnArgs} args - Arguments to create many ModelVersions.
     * @example
     * // Create many ModelVersions
     * const modelVersion = await prisma.modelVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelVersions and only return the `id`
     * const modelVersionWithIdOnly = await prisma.modelVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModelVersion.
     * @param {ModelVersionDeleteArgs} args - Arguments to delete one ModelVersion.
     * @example
     * // Delete one ModelVersion
     * const ModelVersion = await prisma.modelVersion.delete({
     *   where: {
     *     // ... filter to delete one ModelVersion
     *   }
     * })
     * 
     */
    delete<T extends ModelVersionDeleteArgs>(args: SelectSubset<T, ModelVersionDeleteArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModelVersion.
     * @param {ModelVersionUpdateArgs} args - Arguments to update one ModelVersion.
     * @example
     * // Update one ModelVersion
     * const modelVersion = await prisma.modelVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelVersionUpdateArgs>(args: SelectSubset<T, ModelVersionUpdateArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModelVersions.
     * @param {ModelVersionDeleteManyArgs} args - Arguments to filter ModelVersions to delete.
     * @example
     * // Delete a few ModelVersions
     * const { count } = await prisma.modelVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelVersionDeleteManyArgs>(args?: SelectSubset<T, ModelVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelVersions
     * const modelVersion = await prisma.modelVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelVersionUpdateManyArgs>(args: SelectSubset<T, ModelVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModelVersion.
     * @param {ModelVersionUpsertArgs} args - Arguments to update or create a ModelVersion.
     * @example
     * // Update or create a ModelVersion
     * const modelVersion = await prisma.modelVersion.upsert({
     *   create: {
     *     // ... data to create a ModelVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelVersion we want to update
     *   }
     * })
     */
    upsert<T extends ModelVersionUpsertArgs>(args: SelectSubset<T, ModelVersionUpsertArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModelVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelVersionCountArgs} args - Arguments to filter ModelVersions to count.
     * @example
     * // Count the number of ModelVersions
     * const count = await prisma.modelVersion.count({
     *   where: {
     *     // ... the filter for the ModelVersions we want to count
     *   }
     * })
    **/
    count<T extends ModelVersionCountArgs>(
      args?: Subset<T, ModelVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelVersionAggregateArgs>(args: Subset<T, ModelVersionAggregateArgs>): Prisma.PrismaPromise<GetModelVersionAggregateType<T>>

    /**
     * Group by ModelVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelVersionGroupByArgs['orderBy'] }
        : { orderBy?: ModelVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelVersion model
   */
  readonly fields: ModelVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deployments<T extends ModelVersion$deploymentsArgs<ExtArgs> = {}>(args?: Subset<T, ModelVersion$deploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelVersion model
   */ 
  interface ModelVersionFieldRefs {
    readonly id: FieldRef<"ModelVersion", 'String'>
    readonly modelId: FieldRef<"ModelVersion", 'String'>
    readonly version: FieldRef<"ModelVersion", 'String'>
    readonly metrics: FieldRef<"ModelVersion", 'Json'>
    readonly artifacts: FieldRef<"ModelVersion", 'Json'>
    readonly status: FieldRef<"ModelVersion", 'VersionStatus'>
    readonly createdAt: FieldRef<"ModelVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelVersion findUnique
   */
  export type ModelVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which ModelVersion to fetch.
     */
    where: ModelVersionWhereUniqueInput
  }

  /**
   * ModelVersion findUniqueOrThrow
   */
  export type ModelVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which ModelVersion to fetch.
     */
    where: ModelVersionWhereUniqueInput
  }

  /**
   * ModelVersion findFirst
   */
  export type ModelVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which ModelVersion to fetch.
     */
    where?: ModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelVersions to fetch.
     */
    orderBy?: ModelVersionOrderByWithRelationInput | ModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelVersions.
     */
    cursor?: ModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelVersions.
     */
    distinct?: ModelVersionScalarFieldEnum | ModelVersionScalarFieldEnum[]
  }

  /**
   * ModelVersion findFirstOrThrow
   */
  export type ModelVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which ModelVersion to fetch.
     */
    where?: ModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelVersions to fetch.
     */
    orderBy?: ModelVersionOrderByWithRelationInput | ModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelVersions.
     */
    cursor?: ModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelVersions.
     */
    distinct?: ModelVersionScalarFieldEnum | ModelVersionScalarFieldEnum[]
  }

  /**
   * ModelVersion findMany
   */
  export type ModelVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which ModelVersions to fetch.
     */
    where?: ModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelVersions to fetch.
     */
    orderBy?: ModelVersionOrderByWithRelationInput | ModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelVersions.
     */
    cursor?: ModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelVersions.
     */
    skip?: number
    distinct?: ModelVersionScalarFieldEnum | ModelVersionScalarFieldEnum[]
  }

  /**
   * ModelVersion create
   */
  export type ModelVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ModelVersion.
     */
    data: XOR<ModelVersionCreateInput, ModelVersionUncheckedCreateInput>
  }

  /**
   * ModelVersion createMany
   */
  export type ModelVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelVersions.
     */
    data: ModelVersionCreateManyInput | ModelVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelVersion createManyAndReturn
   */
  export type ModelVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModelVersions.
     */
    data: ModelVersionCreateManyInput | ModelVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModelVersion update
   */
  export type ModelVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ModelVersion.
     */
    data: XOR<ModelVersionUpdateInput, ModelVersionUncheckedUpdateInput>
    /**
     * Choose, which ModelVersion to update.
     */
    where: ModelVersionWhereUniqueInput
  }

  /**
   * ModelVersion updateMany
   */
  export type ModelVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelVersions.
     */
    data: XOR<ModelVersionUpdateManyMutationInput, ModelVersionUncheckedUpdateManyInput>
    /**
     * Filter which ModelVersions to update
     */
    where?: ModelVersionWhereInput
  }

  /**
   * ModelVersion upsert
   */
  export type ModelVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ModelVersion to update in case it exists.
     */
    where: ModelVersionWhereUniqueInput
    /**
     * In case the ModelVersion found by the `where` argument doesn't exist, create a new ModelVersion with this data.
     */
    create: XOR<ModelVersionCreateInput, ModelVersionUncheckedCreateInput>
    /**
     * In case the ModelVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelVersionUpdateInput, ModelVersionUncheckedUpdateInput>
  }

  /**
   * ModelVersion delete
   */
  export type ModelVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
    /**
     * Filter which ModelVersion to delete.
     */
    where: ModelVersionWhereUniqueInput
  }

  /**
   * ModelVersion deleteMany
   */
  export type ModelVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelVersions to delete
     */
    where?: ModelVersionWhereInput
  }

  /**
   * ModelVersion.deployments
   */
  export type ModelVersion$deploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    cursor?: DeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * ModelVersion without action
   */
  export type ModelVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelVersion
     */
    select?: ModelVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelVersionInclude<ExtArgs> | null
  }


  /**
   * Model Change
   */

  export type AggregateChange = {
    _count: ChangeCountAggregateOutputType | null
    _min: ChangeMinAggregateOutputType | null
    _max: ChangeMaxAggregateOutputType | null
  }

  export type ChangeMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    userId: string | null
    type: $Enums.ChangeType | null
    content: string | null
    diff: string | null
    description: string | null
    status: $Enums.ChangeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChangeMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    userId: string | null
    type: $Enums.ChangeType | null
    content: string | null
    diff: string | null
    description: string | null
    status: $Enums.ChangeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChangeCountAggregateOutputType = {
    id: number
    modelId: number
    userId: number
    type: number
    content: number
    diff: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChangeMinAggregateInputType = {
    id?: true
    modelId?: true
    userId?: true
    type?: true
    content?: true
    diff?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChangeMaxAggregateInputType = {
    id?: true
    modelId?: true
    userId?: true
    type?: true
    content?: true
    diff?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChangeCountAggregateInputType = {
    id?: true
    modelId?: true
    userId?: true
    type?: true
    content?: true
    diff?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Change to aggregate.
     */
    where?: ChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changes to fetch.
     */
    orderBy?: ChangeOrderByWithRelationInput | ChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Changes
    **/
    _count?: true | ChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeMaxAggregateInputType
  }

  export type GetChangeAggregateType<T extends ChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChange[P]>
      : GetScalarType<T[P], AggregateChange[P]>
  }




  export type ChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeWhereInput
    orderBy?: ChangeOrderByWithAggregationInput | ChangeOrderByWithAggregationInput[]
    by: ChangeScalarFieldEnum[] | ChangeScalarFieldEnum
    having?: ChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeCountAggregateInputType | true
    _min?: ChangeMinAggregateInputType
    _max?: ChangeMaxAggregateInputType
  }

  export type ChangeGroupByOutputType = {
    id: string
    modelId: string
    userId: string
    type: $Enums.ChangeType
    content: string
    diff: string | null
    description: string
    status: $Enums.ChangeStatus
    createdAt: Date
    updatedAt: Date
    _count: ChangeCountAggregateOutputType | null
    _min: ChangeMinAggregateOutputType | null
    _max: ChangeMaxAggregateOutputType | null
  }

  type GetChangeGroupByPayload<T extends ChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeGroupByOutputType[P]>
        }
      >
    >


  export type ChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    diff?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Change$commentsArgs<ExtArgs>
    reviewers?: boolean | Change$reviewersArgs<ExtArgs>
    _count?: boolean | ChangeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["change"]>

  export type ChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    diff?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["change"]>

  export type ChangeSelectScalar = {
    id?: boolean
    modelId?: boolean
    userId?: boolean
    type?: boolean
    content?: boolean
    diff?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Change$commentsArgs<ExtArgs>
    reviewers?: boolean | Change$reviewersArgs<ExtArgs>
    _count?: boolean | ChangeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Change"
    objects: {
      model: Prisma.$ModelPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reviewers: Prisma.$ChangeReviewerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      userId: string
      type: $Enums.ChangeType
      content: string
      diff: string | null
      description: string
      status: $Enums.ChangeStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["change"]>
    composites: {}
  }

  type ChangeGetPayload<S extends boolean | null | undefined | ChangeDefaultArgs> = $Result.GetResult<Prisma.$ChangePayload, S>

  type ChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChangeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChangeCountAggregateInputType | true
    }

  export interface ChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Change'], meta: { name: 'Change' } }
    /**
     * Find zero or one Change that matches the filter.
     * @param {ChangeFindUniqueArgs} args - Arguments to find a Change
     * @example
     * // Get one Change
     * const change = await prisma.change.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeFindUniqueArgs>(args: SelectSubset<T, ChangeFindUniqueArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Change that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChangeFindUniqueOrThrowArgs} args - Arguments to find a Change
     * @example
     * // Get one Change
     * const change = await prisma.change.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Change that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeFindFirstArgs} args - Arguments to find a Change
     * @example
     * // Get one Change
     * const change = await prisma.change.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeFindFirstArgs>(args?: SelectSubset<T, ChangeFindFirstArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Change that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeFindFirstOrThrowArgs} args - Arguments to find a Change
     * @example
     * // Get one Change
     * const change = await prisma.change.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Changes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Changes
     * const changes = await prisma.change.findMany()
     * 
     * // Get first 10 Changes
     * const changes = await prisma.change.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeWithIdOnly = await prisma.change.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeFindManyArgs>(args?: SelectSubset<T, ChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Change.
     * @param {ChangeCreateArgs} args - Arguments to create a Change.
     * @example
     * // Create one Change
     * const Change = await prisma.change.create({
     *   data: {
     *     // ... data to create a Change
     *   }
     * })
     * 
     */
    create<T extends ChangeCreateArgs>(args: SelectSubset<T, ChangeCreateArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Changes.
     * @param {ChangeCreateManyArgs} args - Arguments to create many Changes.
     * @example
     * // Create many Changes
     * const change = await prisma.change.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeCreateManyArgs>(args?: SelectSubset<T, ChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Changes and returns the data saved in the database.
     * @param {ChangeCreateManyAndReturnArgs} args - Arguments to create many Changes.
     * @example
     * // Create many Changes
     * const change = await prisma.change.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Changes and only return the `id`
     * const changeWithIdOnly = await prisma.change.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Change.
     * @param {ChangeDeleteArgs} args - Arguments to delete one Change.
     * @example
     * // Delete one Change
     * const Change = await prisma.change.delete({
     *   where: {
     *     // ... filter to delete one Change
     *   }
     * })
     * 
     */
    delete<T extends ChangeDeleteArgs>(args: SelectSubset<T, ChangeDeleteArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Change.
     * @param {ChangeUpdateArgs} args - Arguments to update one Change.
     * @example
     * // Update one Change
     * const change = await prisma.change.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeUpdateArgs>(args: SelectSubset<T, ChangeUpdateArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Changes.
     * @param {ChangeDeleteManyArgs} args - Arguments to filter Changes to delete.
     * @example
     * // Delete a few Changes
     * const { count } = await prisma.change.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeDeleteManyArgs>(args?: SelectSubset<T, ChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Changes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Changes
     * const change = await prisma.change.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeUpdateManyArgs>(args: SelectSubset<T, ChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Change.
     * @param {ChangeUpsertArgs} args - Arguments to update or create a Change.
     * @example
     * // Update or create a Change
     * const change = await prisma.change.upsert({
     *   create: {
     *     // ... data to create a Change
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Change we want to update
     *   }
     * })
     */
    upsert<T extends ChangeUpsertArgs>(args: SelectSubset<T, ChangeUpsertArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Changes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeCountArgs} args - Arguments to filter Changes to count.
     * @example
     * // Count the number of Changes
     * const count = await prisma.change.count({
     *   where: {
     *     // ... the filter for the Changes we want to count
     *   }
     * })
    **/
    count<T extends ChangeCountArgs>(
      args?: Subset<T, ChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Change.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeAggregateArgs>(args: Subset<T, ChangeAggregateArgs>): Prisma.PrismaPromise<GetChangeAggregateType<T>>

    /**
     * Group by Change.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeGroupByArgs['orderBy'] }
        : { orderBy?: ChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Change model
   */
  readonly fields: ChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Change.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends Change$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Change$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    reviewers<T extends Change$reviewersArgs<ExtArgs> = {}>(args?: Subset<T, Change$reviewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Change model
   */ 
  interface ChangeFieldRefs {
    readonly id: FieldRef<"Change", 'String'>
    readonly modelId: FieldRef<"Change", 'String'>
    readonly userId: FieldRef<"Change", 'String'>
    readonly type: FieldRef<"Change", 'ChangeType'>
    readonly content: FieldRef<"Change", 'String'>
    readonly diff: FieldRef<"Change", 'String'>
    readonly description: FieldRef<"Change", 'String'>
    readonly status: FieldRef<"Change", 'ChangeStatus'>
    readonly createdAt: FieldRef<"Change", 'DateTime'>
    readonly updatedAt: FieldRef<"Change", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Change findUnique
   */
  export type ChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * Filter, which Change to fetch.
     */
    where: ChangeWhereUniqueInput
  }

  /**
   * Change findUniqueOrThrow
   */
  export type ChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * Filter, which Change to fetch.
     */
    where: ChangeWhereUniqueInput
  }

  /**
   * Change findFirst
   */
  export type ChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * Filter, which Change to fetch.
     */
    where?: ChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changes to fetch.
     */
    orderBy?: ChangeOrderByWithRelationInput | ChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Changes.
     */
    cursor?: ChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Changes.
     */
    distinct?: ChangeScalarFieldEnum | ChangeScalarFieldEnum[]
  }

  /**
   * Change findFirstOrThrow
   */
  export type ChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * Filter, which Change to fetch.
     */
    where?: ChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changes to fetch.
     */
    orderBy?: ChangeOrderByWithRelationInput | ChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Changes.
     */
    cursor?: ChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Changes.
     */
    distinct?: ChangeScalarFieldEnum | ChangeScalarFieldEnum[]
  }

  /**
   * Change findMany
   */
  export type ChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * Filter, which Changes to fetch.
     */
    where?: ChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changes to fetch.
     */
    orderBy?: ChangeOrderByWithRelationInput | ChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Changes.
     */
    cursor?: ChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changes.
     */
    skip?: number
    distinct?: ChangeScalarFieldEnum | ChangeScalarFieldEnum[]
  }

  /**
   * Change create
   */
  export type ChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a Change.
     */
    data: XOR<ChangeCreateInput, ChangeUncheckedCreateInput>
  }

  /**
   * Change createMany
   */
  export type ChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Changes.
     */
    data: ChangeCreateManyInput | ChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Change createManyAndReturn
   */
  export type ChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Changes.
     */
    data: ChangeCreateManyInput | ChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Change update
   */
  export type ChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a Change.
     */
    data: XOR<ChangeUpdateInput, ChangeUncheckedUpdateInput>
    /**
     * Choose, which Change to update.
     */
    where: ChangeWhereUniqueInput
  }

  /**
   * Change updateMany
   */
  export type ChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Changes.
     */
    data: XOR<ChangeUpdateManyMutationInput, ChangeUncheckedUpdateManyInput>
    /**
     * Filter which Changes to update
     */
    where?: ChangeWhereInput
  }

  /**
   * Change upsert
   */
  export type ChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the Change to update in case it exists.
     */
    where: ChangeWhereUniqueInput
    /**
     * In case the Change found by the `where` argument doesn't exist, create a new Change with this data.
     */
    create: XOR<ChangeCreateInput, ChangeUncheckedCreateInput>
    /**
     * In case the Change was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeUpdateInput, ChangeUncheckedUpdateInput>
  }

  /**
   * Change delete
   */
  export type ChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
    /**
     * Filter which Change to delete.
     */
    where: ChangeWhereUniqueInput
  }

  /**
   * Change deleteMany
   */
  export type ChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Changes to delete
     */
    where?: ChangeWhereInput
  }

  /**
   * Change.comments
   */
  export type Change$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Change.reviewers
   */
  export type Change$reviewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    where?: ChangeReviewerWhereInput
    orderBy?: ChangeReviewerOrderByWithRelationInput | ChangeReviewerOrderByWithRelationInput[]
    cursor?: ChangeReviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeReviewerScalarFieldEnum | ChangeReviewerScalarFieldEnum[]
  }

  /**
   * Change without action
   */
  export type ChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Change
     */
    select?: ChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeInclude<ExtArgs> | null
  }


  /**
   * Model ChangeReviewer
   */

  export type AggregateChangeReviewer = {
    _count: ChangeReviewerCountAggregateOutputType | null
    _min: ChangeReviewerMinAggregateOutputType | null
    _max: ChangeReviewerMaxAggregateOutputType | null
  }

  export type ChangeReviewerMinAggregateOutputType = {
    id: string | null
    changeId: string | null
    userId: string | null
    status: $Enums.ReviewStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChangeReviewerMaxAggregateOutputType = {
    id: string | null
    changeId: string | null
    userId: string | null
    status: $Enums.ReviewStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChangeReviewerCountAggregateOutputType = {
    id: number
    changeId: number
    userId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChangeReviewerMinAggregateInputType = {
    id?: true
    changeId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChangeReviewerMaxAggregateInputType = {
    id?: true
    changeId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChangeReviewerCountAggregateInputType = {
    id?: true
    changeId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChangeReviewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeReviewer to aggregate.
     */
    where?: ChangeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeReviewers to fetch.
     */
    orderBy?: ChangeReviewerOrderByWithRelationInput | ChangeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeReviewers
    **/
    _count?: true | ChangeReviewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeReviewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeReviewerMaxAggregateInputType
  }

  export type GetChangeReviewerAggregateType<T extends ChangeReviewerAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeReviewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeReviewer[P]>
      : GetScalarType<T[P], AggregateChangeReviewer[P]>
  }




  export type ChangeReviewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeReviewerWhereInput
    orderBy?: ChangeReviewerOrderByWithAggregationInput | ChangeReviewerOrderByWithAggregationInput[]
    by: ChangeReviewerScalarFieldEnum[] | ChangeReviewerScalarFieldEnum
    having?: ChangeReviewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeReviewerCountAggregateInputType | true
    _min?: ChangeReviewerMinAggregateInputType
    _max?: ChangeReviewerMaxAggregateInputType
  }

  export type ChangeReviewerGroupByOutputType = {
    id: string
    changeId: string
    userId: string
    status: $Enums.ReviewStatus
    createdAt: Date
    updatedAt: Date
    _count: ChangeReviewerCountAggregateOutputType | null
    _min: ChangeReviewerMinAggregateOutputType | null
    _max: ChangeReviewerMaxAggregateOutputType | null
  }

  type GetChangeReviewerGroupByPayload<T extends ChangeReviewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeReviewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeReviewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeReviewerGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeReviewerGroupByOutputType[P]>
        }
      >
    >


  export type ChangeReviewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    change?: boolean | ChangeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeReviewer"]>

  export type ChangeReviewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    change?: boolean | ChangeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeReviewer"]>

  export type ChangeReviewerSelectScalar = {
    id?: boolean
    changeId?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChangeReviewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    change?: boolean | ChangeDefaultArgs<ExtArgs>
  }
  export type ChangeReviewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    change?: boolean | ChangeDefaultArgs<ExtArgs>
  }

  export type $ChangeReviewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeReviewer"
    objects: {
      change: Prisma.$ChangePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      changeId: string
      userId: string
      status: $Enums.ReviewStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["changeReviewer"]>
    composites: {}
  }

  type ChangeReviewerGetPayload<S extends boolean | null | undefined | ChangeReviewerDefaultArgs> = $Result.GetResult<Prisma.$ChangeReviewerPayload, S>

  type ChangeReviewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChangeReviewerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChangeReviewerCountAggregateInputType | true
    }

  export interface ChangeReviewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeReviewer'], meta: { name: 'ChangeReviewer' } }
    /**
     * Find zero or one ChangeReviewer that matches the filter.
     * @param {ChangeReviewerFindUniqueArgs} args - Arguments to find a ChangeReviewer
     * @example
     * // Get one ChangeReviewer
     * const changeReviewer = await prisma.changeReviewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeReviewerFindUniqueArgs>(args: SelectSubset<T, ChangeReviewerFindUniqueArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChangeReviewer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChangeReviewerFindUniqueOrThrowArgs} args - Arguments to find a ChangeReviewer
     * @example
     * // Get one ChangeReviewer
     * const changeReviewer = await prisma.changeReviewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeReviewerFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeReviewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChangeReviewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeReviewerFindFirstArgs} args - Arguments to find a ChangeReviewer
     * @example
     * // Get one ChangeReviewer
     * const changeReviewer = await prisma.changeReviewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeReviewerFindFirstArgs>(args?: SelectSubset<T, ChangeReviewerFindFirstArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChangeReviewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeReviewerFindFirstOrThrowArgs} args - Arguments to find a ChangeReviewer
     * @example
     * // Get one ChangeReviewer
     * const changeReviewer = await prisma.changeReviewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeReviewerFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeReviewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChangeReviewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeReviewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeReviewers
     * const changeReviewers = await prisma.changeReviewer.findMany()
     * 
     * // Get first 10 ChangeReviewers
     * const changeReviewers = await prisma.changeReviewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeReviewerWithIdOnly = await prisma.changeReviewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeReviewerFindManyArgs>(args?: SelectSubset<T, ChangeReviewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChangeReviewer.
     * @param {ChangeReviewerCreateArgs} args - Arguments to create a ChangeReviewer.
     * @example
     * // Create one ChangeReviewer
     * const ChangeReviewer = await prisma.changeReviewer.create({
     *   data: {
     *     // ... data to create a ChangeReviewer
     *   }
     * })
     * 
     */
    create<T extends ChangeReviewerCreateArgs>(args: SelectSubset<T, ChangeReviewerCreateArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChangeReviewers.
     * @param {ChangeReviewerCreateManyArgs} args - Arguments to create many ChangeReviewers.
     * @example
     * // Create many ChangeReviewers
     * const changeReviewer = await prisma.changeReviewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeReviewerCreateManyArgs>(args?: SelectSubset<T, ChangeReviewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChangeReviewers and returns the data saved in the database.
     * @param {ChangeReviewerCreateManyAndReturnArgs} args - Arguments to create many ChangeReviewers.
     * @example
     * // Create many ChangeReviewers
     * const changeReviewer = await prisma.changeReviewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChangeReviewers and only return the `id`
     * const changeReviewerWithIdOnly = await prisma.changeReviewer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeReviewerCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeReviewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChangeReviewer.
     * @param {ChangeReviewerDeleteArgs} args - Arguments to delete one ChangeReviewer.
     * @example
     * // Delete one ChangeReviewer
     * const ChangeReviewer = await prisma.changeReviewer.delete({
     *   where: {
     *     // ... filter to delete one ChangeReviewer
     *   }
     * })
     * 
     */
    delete<T extends ChangeReviewerDeleteArgs>(args: SelectSubset<T, ChangeReviewerDeleteArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChangeReviewer.
     * @param {ChangeReviewerUpdateArgs} args - Arguments to update one ChangeReviewer.
     * @example
     * // Update one ChangeReviewer
     * const changeReviewer = await prisma.changeReviewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeReviewerUpdateArgs>(args: SelectSubset<T, ChangeReviewerUpdateArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChangeReviewers.
     * @param {ChangeReviewerDeleteManyArgs} args - Arguments to filter ChangeReviewers to delete.
     * @example
     * // Delete a few ChangeReviewers
     * const { count } = await prisma.changeReviewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeReviewerDeleteManyArgs>(args?: SelectSubset<T, ChangeReviewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeReviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeReviewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeReviewers
     * const changeReviewer = await prisma.changeReviewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeReviewerUpdateManyArgs>(args: SelectSubset<T, ChangeReviewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChangeReviewer.
     * @param {ChangeReviewerUpsertArgs} args - Arguments to update or create a ChangeReviewer.
     * @example
     * // Update or create a ChangeReviewer
     * const changeReviewer = await prisma.changeReviewer.upsert({
     *   create: {
     *     // ... data to create a ChangeReviewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeReviewer we want to update
     *   }
     * })
     */
    upsert<T extends ChangeReviewerUpsertArgs>(args: SelectSubset<T, ChangeReviewerUpsertArgs<ExtArgs>>): Prisma__ChangeReviewerClient<$Result.GetResult<Prisma.$ChangeReviewerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChangeReviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeReviewerCountArgs} args - Arguments to filter ChangeReviewers to count.
     * @example
     * // Count the number of ChangeReviewers
     * const count = await prisma.changeReviewer.count({
     *   where: {
     *     // ... the filter for the ChangeReviewers we want to count
     *   }
     * })
    **/
    count<T extends ChangeReviewerCountArgs>(
      args?: Subset<T, ChangeReviewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeReviewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeReviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeReviewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeReviewerAggregateArgs>(args: Subset<T, ChangeReviewerAggregateArgs>): Prisma.PrismaPromise<GetChangeReviewerAggregateType<T>>

    /**
     * Group by ChangeReviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeReviewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeReviewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeReviewerGroupByArgs['orderBy'] }
        : { orderBy?: ChangeReviewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeReviewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeReviewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeReviewer model
   */
  readonly fields: ChangeReviewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeReviewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeReviewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    change<T extends ChangeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChangeDefaultArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeReviewer model
   */ 
  interface ChangeReviewerFieldRefs {
    readonly id: FieldRef<"ChangeReviewer", 'String'>
    readonly changeId: FieldRef<"ChangeReviewer", 'String'>
    readonly userId: FieldRef<"ChangeReviewer", 'String'>
    readonly status: FieldRef<"ChangeReviewer", 'ReviewStatus'>
    readonly createdAt: FieldRef<"ChangeReviewer", 'DateTime'>
    readonly updatedAt: FieldRef<"ChangeReviewer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChangeReviewer findUnique
   */
  export type ChangeReviewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChangeReviewer to fetch.
     */
    where: ChangeReviewerWhereUniqueInput
  }

  /**
   * ChangeReviewer findUniqueOrThrow
   */
  export type ChangeReviewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChangeReviewer to fetch.
     */
    where: ChangeReviewerWhereUniqueInput
  }

  /**
   * ChangeReviewer findFirst
   */
  export type ChangeReviewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChangeReviewer to fetch.
     */
    where?: ChangeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeReviewers to fetch.
     */
    orderBy?: ChangeReviewerOrderByWithRelationInput | ChangeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeReviewers.
     */
    cursor?: ChangeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeReviewers.
     */
    distinct?: ChangeReviewerScalarFieldEnum | ChangeReviewerScalarFieldEnum[]
  }

  /**
   * ChangeReviewer findFirstOrThrow
   */
  export type ChangeReviewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChangeReviewer to fetch.
     */
    where?: ChangeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeReviewers to fetch.
     */
    orderBy?: ChangeReviewerOrderByWithRelationInput | ChangeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeReviewers.
     */
    cursor?: ChangeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeReviewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeReviewers.
     */
    distinct?: ChangeReviewerScalarFieldEnum | ChangeReviewerScalarFieldEnum[]
  }

  /**
   * ChangeReviewer findMany
   */
  export type ChangeReviewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * Filter, which ChangeReviewers to fetch.
     */
    where?: ChangeReviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeReviewers to fetch.
     */
    orderBy?: ChangeReviewerOrderByWithRelationInput | ChangeReviewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeReviewers.
     */
    cursor?: ChangeReviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeReviewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeReviewers.
     */
    skip?: number
    distinct?: ChangeReviewerScalarFieldEnum | ChangeReviewerScalarFieldEnum[]
  }

  /**
   * ChangeReviewer create
   */
  export type ChangeReviewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeReviewer.
     */
    data: XOR<ChangeReviewerCreateInput, ChangeReviewerUncheckedCreateInput>
  }

  /**
   * ChangeReviewer createMany
   */
  export type ChangeReviewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeReviewers.
     */
    data: ChangeReviewerCreateManyInput | ChangeReviewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChangeReviewer createManyAndReturn
   */
  export type ChangeReviewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChangeReviewers.
     */
    data: ChangeReviewerCreateManyInput | ChangeReviewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeReviewer update
   */
  export type ChangeReviewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeReviewer.
     */
    data: XOR<ChangeReviewerUpdateInput, ChangeReviewerUncheckedUpdateInput>
    /**
     * Choose, which ChangeReviewer to update.
     */
    where: ChangeReviewerWhereUniqueInput
  }

  /**
   * ChangeReviewer updateMany
   */
  export type ChangeReviewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeReviewers.
     */
    data: XOR<ChangeReviewerUpdateManyMutationInput, ChangeReviewerUncheckedUpdateManyInput>
    /**
     * Filter which ChangeReviewers to update
     */
    where?: ChangeReviewerWhereInput
  }

  /**
   * ChangeReviewer upsert
   */
  export type ChangeReviewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeReviewer to update in case it exists.
     */
    where: ChangeReviewerWhereUniqueInput
    /**
     * In case the ChangeReviewer found by the `where` argument doesn't exist, create a new ChangeReviewer with this data.
     */
    create: XOR<ChangeReviewerCreateInput, ChangeReviewerUncheckedCreateInput>
    /**
     * In case the ChangeReviewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeReviewerUpdateInput, ChangeReviewerUncheckedUpdateInput>
  }

  /**
   * ChangeReviewer delete
   */
  export type ChangeReviewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
    /**
     * Filter which ChangeReviewer to delete.
     */
    where: ChangeReviewerWhereUniqueInput
  }

  /**
   * ChangeReviewer deleteMany
   */
  export type ChangeReviewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeReviewers to delete
     */
    where?: ChangeReviewerWhereInput
  }

  /**
   * ChangeReviewer without action
   */
  export type ChangeReviewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeReviewer
     */
    select?: ChangeReviewerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeReviewerInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    line: number | null
  }

  export type CommentSumAggregateOutputType = {
    line: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    changeId: string | null
    userId: string | null
    content: string | null
    file: string | null
    line: number | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    changeId: string | null
    userId: string | null
    content: string | null
    file: string | null
    line: number | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    changeId: number
    userId: number
    content: number
    file: number
    line: number
    createdAt: number
    updatedAt: number
    parentId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    line?: true
  }

  export type CommentSumAggregateInputType = {
    line?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    changeId?: true
    userId?: true
    content?: true
    file?: true
    line?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    changeId?: true
    userId?: true
    content?: true
    file?: true
    line?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    changeId?: true
    userId?: true
    content?: true
    file?: true
    line?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    changeId: string
    userId: string
    content: string
    file: string | null
    line: number | null
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeId?: boolean
    userId?: boolean
    content?: boolean
    file?: boolean
    line?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    change?: boolean | ChangeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeId?: boolean
    userId?: boolean
    content?: boolean
    file?: boolean
    line?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    change?: boolean | ChangeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    changeId?: boolean
    userId?: boolean
    content?: boolean
    file?: boolean
    line?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    change?: boolean | ChangeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    change?: boolean | ChangeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      change: Prisma.$ChangePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      reactions: Prisma.$CommentReactionPayload<ExtArgs>[]
      replies: Prisma.$CommentPayload<ExtArgs>[]
      parent: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      changeId: string
      userId: string
      content: string
      file: string | null
      line: number | null
      createdAt: Date
      updatedAt: Date
      parentId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    change<T extends ChangeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChangeDefaultArgs<ExtArgs>>): Prisma__ChangeClient<$Result.GetResult<Prisma.$ChangePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reactions<T extends Comment$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany"> | Null>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly changeId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly file: FieldRef<"Comment", 'String'>
    readonly line: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly parentId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.reactions
   */
  export type Comment$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    cursor?: CommentReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CommentReaction
   */

  export type AggregateCommentReaction = {
    _count: CommentReactionCountAggregateOutputType | null
    _min: CommentReactionMinAggregateOutputType | null
    _max: CommentReactionMaxAggregateOutputType | null
  }

  export type CommentReactionMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type CommentReactionMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type CommentReactionCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type CommentReactionMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type CommentReactionMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type CommentReactionCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type CommentReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReaction to aggregate.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentReactions
    **/
    _count?: true | CommentReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentReactionMaxAggregateInputType
  }

  export type GetCommentReactionAggregateType<T extends CommentReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentReaction[P]>
      : GetScalarType<T[P], AggregateCommentReaction[P]>
  }




  export type CommentReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithAggregationInput | CommentReactionOrderByWithAggregationInput[]
    by: CommentReactionScalarFieldEnum[] | CommentReactionScalarFieldEnum
    having?: CommentReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentReactionCountAggregateInputType | true
    _min?: CommentReactionMinAggregateInputType
    _max?: CommentReactionMaxAggregateInputType
  }

  export type CommentReactionGroupByOutputType = {
    id: string
    commentId: string
    userId: string
    type: string
    createdAt: Date
    _count: CommentReactionCountAggregateOutputType | null
    _min: CommentReactionMinAggregateOutputType | null
    _max: CommentReactionMaxAggregateOutputType | null
  }

  type GetCommentReactionGroupByPayload<T extends CommentReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentReactionGroupByOutputType[P]>
            : GetScalarType<T[P], CommentReactionGroupByOutputType[P]>
        }
      >
    >


  export type CommentReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectScalar = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type CommentReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type CommentReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $CommentReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentReaction"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      userId: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["commentReaction"]>
    composites: {}
  }

  type CommentReactionGetPayload<S extends boolean | null | undefined | CommentReactionDefaultArgs> = $Result.GetResult<Prisma.$CommentReactionPayload, S>

  type CommentReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentReactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentReactionCountAggregateInputType | true
    }

  export interface CommentReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentReaction'], meta: { name: 'CommentReaction' } }
    /**
     * Find zero or one CommentReaction that matches the filter.
     * @param {CommentReactionFindUniqueArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentReactionFindUniqueArgs>(args: SelectSubset<T, CommentReactionFindUniqueArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommentReaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentReactionFindUniqueOrThrowArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommentReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindFirstArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentReactionFindFirstArgs>(args?: SelectSubset<T, CommentReactionFindFirstArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommentReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindFirstOrThrowArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommentReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentReactions
     * const commentReactions = await prisma.commentReaction.findMany()
     * 
     * // Get first 10 CommentReactions
     * const commentReactions = await prisma.commentReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentReactionFindManyArgs>(args?: SelectSubset<T, CommentReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommentReaction.
     * @param {CommentReactionCreateArgs} args - Arguments to create a CommentReaction.
     * @example
     * // Create one CommentReaction
     * const CommentReaction = await prisma.commentReaction.create({
     *   data: {
     *     // ... data to create a CommentReaction
     *   }
     * })
     * 
     */
    create<T extends CommentReactionCreateArgs>(args: SelectSubset<T, CommentReactionCreateArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommentReactions.
     * @param {CommentReactionCreateManyArgs} args - Arguments to create many CommentReactions.
     * @example
     * // Create many CommentReactions
     * const commentReaction = await prisma.commentReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentReactionCreateManyArgs>(args?: SelectSubset<T, CommentReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentReactions and returns the data saved in the database.
     * @param {CommentReactionCreateManyAndReturnArgs} args - Arguments to create many CommentReactions.
     * @example
     * // Create many CommentReactions
     * const commentReaction = await prisma.commentReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentReactions and only return the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommentReaction.
     * @param {CommentReactionDeleteArgs} args - Arguments to delete one CommentReaction.
     * @example
     * // Delete one CommentReaction
     * const CommentReaction = await prisma.commentReaction.delete({
     *   where: {
     *     // ... filter to delete one CommentReaction
     *   }
     * })
     * 
     */
    delete<T extends CommentReactionDeleteArgs>(args: SelectSubset<T, CommentReactionDeleteArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommentReaction.
     * @param {CommentReactionUpdateArgs} args - Arguments to update one CommentReaction.
     * @example
     * // Update one CommentReaction
     * const commentReaction = await prisma.commentReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentReactionUpdateArgs>(args: SelectSubset<T, CommentReactionUpdateArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommentReactions.
     * @param {CommentReactionDeleteManyArgs} args - Arguments to filter CommentReactions to delete.
     * @example
     * // Delete a few CommentReactions
     * const { count } = await prisma.commentReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentReactionDeleteManyArgs>(args?: SelectSubset<T, CommentReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentReactions
     * const commentReaction = await prisma.commentReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentReactionUpdateManyArgs>(args: SelectSubset<T, CommentReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentReaction.
     * @param {CommentReactionUpsertArgs} args - Arguments to update or create a CommentReaction.
     * @example
     * // Update or create a CommentReaction
     * const commentReaction = await prisma.commentReaction.upsert({
     *   create: {
     *     // ... data to create a CommentReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentReaction we want to update
     *   }
     * })
     */
    upsert<T extends CommentReactionUpsertArgs>(args: SelectSubset<T, CommentReactionUpsertArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionCountArgs} args - Arguments to filter CommentReactions to count.
     * @example
     * // Count the number of CommentReactions
     * const count = await prisma.commentReaction.count({
     *   where: {
     *     // ... the filter for the CommentReactions we want to count
     *   }
     * })
    **/
    count<T extends CommentReactionCountArgs>(
      args?: Subset<T, CommentReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentReactionAggregateArgs>(args: Subset<T, CommentReactionAggregateArgs>): Prisma.PrismaPromise<GetCommentReactionAggregateType<T>>

    /**
     * Group by CommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentReactionGroupByArgs['orderBy'] }
        : { orderBy?: CommentReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentReaction model
   */
  readonly fields: CommentReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentReaction model
   */ 
  interface CommentReactionFieldRefs {
    readonly id: FieldRef<"CommentReaction", 'String'>
    readonly commentId: FieldRef<"CommentReaction", 'String'>
    readonly userId: FieldRef<"CommentReaction", 'String'>
    readonly type: FieldRef<"CommentReaction", 'String'>
    readonly createdAt: FieldRef<"CommentReaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentReaction findUnique
   */
  export type CommentReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction findUniqueOrThrow
   */
  export type CommentReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction findFirst
   */
  export type CommentReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReactions.
     */
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction findFirstOrThrow
   */
  export type CommentReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReactions.
     */
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction findMany
   */
  export type CommentReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReactions to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction create
   */
  export type CommentReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentReaction.
     */
    data: XOR<CommentReactionCreateInput, CommentReactionUncheckedCreateInput>
  }

  /**
   * CommentReaction createMany
   */
  export type CommentReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentReactions.
     */
    data: CommentReactionCreateManyInput | CommentReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentReaction createManyAndReturn
   */
  export type CommentReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommentReactions.
     */
    data: CommentReactionCreateManyInput | CommentReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReaction update
   */
  export type CommentReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentReaction.
     */
    data: XOR<CommentReactionUpdateInput, CommentReactionUncheckedUpdateInput>
    /**
     * Choose, which CommentReaction to update.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction updateMany
   */
  export type CommentReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentReactions.
     */
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyInput>
    /**
     * Filter which CommentReactions to update
     */
    where?: CommentReactionWhereInput
  }

  /**
   * CommentReaction upsert
   */
  export type CommentReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentReaction to update in case it exists.
     */
    where: CommentReactionWhereUniqueInput
    /**
     * In case the CommentReaction found by the `where` argument doesn't exist, create a new CommentReaction with this data.
     */
    create: XOR<CommentReactionCreateInput, CommentReactionUncheckedCreateInput>
    /**
     * In case the CommentReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentReactionUpdateInput, CommentReactionUncheckedUpdateInput>
  }

  /**
   * CommentReaction delete
   */
  export type CommentReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter which CommentReaction to delete.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction deleteMany
   */
  export type CommentReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReactions to delete
     */
    where?: CommentReactionWhereInput
  }

  /**
   * CommentReaction without action
   */
  export type CommentReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
  }


  /**
   * Model Deployment
   */

  export type AggregateDeployment = {
    _count: DeploymentCountAggregateOutputType | null
    _min: DeploymentMinAggregateOutputType | null
    _max: DeploymentMaxAggregateOutputType | null
  }

  export type DeploymentMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    versionId: string | null
    environment: string | null
    status: $Enums.DeploymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeploymentMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    versionId: string | null
    environment: string | null
    status: $Enums.DeploymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeploymentCountAggregateOutputType = {
    id: number
    modelId: number
    versionId: number
    environment: number
    status: number
    metrics: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeploymentMinAggregateInputType = {
    id?: true
    modelId?: true
    versionId?: true
    environment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeploymentMaxAggregateInputType = {
    id?: true
    modelId?: true
    versionId?: true
    environment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeploymentCountAggregateInputType = {
    id?: true
    modelId?: true
    versionId?: true
    environment?: true
    status?: true
    metrics?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeploymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deployment to aggregate.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deployments
    **/
    _count?: true | DeploymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeploymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeploymentMaxAggregateInputType
  }

  export type GetDeploymentAggregateType<T extends DeploymentAggregateArgs> = {
        [P in keyof T & keyof AggregateDeployment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeployment[P]>
      : GetScalarType<T[P], AggregateDeployment[P]>
  }




  export type DeploymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithAggregationInput | DeploymentOrderByWithAggregationInput[]
    by: DeploymentScalarFieldEnum[] | DeploymentScalarFieldEnum
    having?: DeploymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeploymentCountAggregateInputType | true
    _min?: DeploymentMinAggregateInputType
    _max?: DeploymentMaxAggregateInputType
  }

  export type DeploymentGroupByOutputType = {
    id: string
    modelId: string
    versionId: string
    environment: string
    status: $Enums.DeploymentStatus
    metrics: JsonValue | null
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DeploymentCountAggregateOutputType | null
    _min: DeploymentMinAggregateOutputType | null
    _max: DeploymentMaxAggregateOutputType | null
  }

  type GetDeploymentGroupByPayload<T extends DeploymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeploymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeploymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeploymentGroupByOutputType[P]>
            : GetScalarType<T[P], DeploymentGroupByOutputType[P]>
        }
      >
    >


  export type DeploymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    versionId?: boolean
    environment?: boolean
    status?: boolean
    metrics?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    version?: boolean | ModelVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deployment"]>

  export type DeploymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    versionId?: boolean
    environment?: boolean
    status?: boolean
    metrics?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | ModelDefaultArgs<ExtArgs>
    version?: boolean | ModelVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deployment"]>

  export type DeploymentSelectScalar = {
    id?: boolean
    modelId?: boolean
    versionId?: boolean
    environment?: boolean
    status?: boolean
    metrics?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeploymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    version?: boolean | ModelVersionDefaultArgs<ExtArgs>
  }
  export type DeploymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | ModelDefaultArgs<ExtArgs>
    version?: boolean | ModelVersionDefaultArgs<ExtArgs>
  }

  export type $DeploymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deployment"
    objects: {
      model: Prisma.$ModelPayload<ExtArgs>
      version: Prisma.$ModelVersionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      versionId: string
      environment: string
      status: $Enums.DeploymentStatus
      metrics: Prisma.JsonValue | null
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deployment"]>
    composites: {}
  }

  type DeploymentGetPayload<S extends boolean | null | undefined | DeploymentDefaultArgs> = $Result.GetResult<Prisma.$DeploymentPayload, S>

  type DeploymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeploymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeploymentCountAggregateInputType | true
    }

  export interface DeploymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deployment'], meta: { name: 'Deployment' } }
    /**
     * Find zero or one Deployment that matches the filter.
     * @param {DeploymentFindUniqueArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeploymentFindUniqueArgs>(args: SelectSubset<T, DeploymentFindUniqueArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deployment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeploymentFindUniqueOrThrowArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeploymentFindUniqueOrThrowArgs>(args: SelectSubset<T, DeploymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deployment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindFirstArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeploymentFindFirstArgs>(args?: SelectSubset<T, DeploymentFindFirstArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deployment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindFirstOrThrowArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeploymentFindFirstOrThrowArgs>(args?: SelectSubset<T, DeploymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deployments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deployments
     * const deployments = await prisma.deployment.findMany()
     * 
     * // Get first 10 Deployments
     * const deployments = await prisma.deployment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deploymentWithIdOnly = await prisma.deployment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeploymentFindManyArgs>(args?: SelectSubset<T, DeploymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deployment.
     * @param {DeploymentCreateArgs} args - Arguments to create a Deployment.
     * @example
     * // Create one Deployment
     * const Deployment = await prisma.deployment.create({
     *   data: {
     *     // ... data to create a Deployment
     *   }
     * })
     * 
     */
    create<T extends DeploymentCreateArgs>(args: SelectSubset<T, DeploymentCreateArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deployments.
     * @param {DeploymentCreateManyArgs} args - Arguments to create many Deployments.
     * @example
     * // Create many Deployments
     * const deployment = await prisma.deployment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeploymentCreateManyArgs>(args?: SelectSubset<T, DeploymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deployments and returns the data saved in the database.
     * @param {DeploymentCreateManyAndReturnArgs} args - Arguments to create many Deployments.
     * @example
     * // Create many Deployments
     * const deployment = await prisma.deployment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deployments and only return the `id`
     * const deploymentWithIdOnly = await prisma.deployment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeploymentCreateManyAndReturnArgs>(args?: SelectSubset<T, DeploymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deployment.
     * @param {DeploymentDeleteArgs} args - Arguments to delete one Deployment.
     * @example
     * // Delete one Deployment
     * const Deployment = await prisma.deployment.delete({
     *   where: {
     *     // ... filter to delete one Deployment
     *   }
     * })
     * 
     */
    delete<T extends DeploymentDeleteArgs>(args: SelectSubset<T, DeploymentDeleteArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deployment.
     * @param {DeploymentUpdateArgs} args - Arguments to update one Deployment.
     * @example
     * // Update one Deployment
     * const deployment = await prisma.deployment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeploymentUpdateArgs>(args: SelectSubset<T, DeploymentUpdateArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deployments.
     * @param {DeploymentDeleteManyArgs} args - Arguments to filter Deployments to delete.
     * @example
     * // Delete a few Deployments
     * const { count } = await prisma.deployment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeploymentDeleteManyArgs>(args?: SelectSubset<T, DeploymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deployments
     * const deployment = await prisma.deployment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeploymentUpdateManyArgs>(args: SelectSubset<T, DeploymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deployment.
     * @param {DeploymentUpsertArgs} args - Arguments to update or create a Deployment.
     * @example
     * // Update or create a Deployment
     * const deployment = await prisma.deployment.upsert({
     *   create: {
     *     // ... data to create a Deployment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deployment we want to update
     *   }
     * })
     */
    upsert<T extends DeploymentUpsertArgs>(args: SelectSubset<T, DeploymentUpsertArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentCountArgs} args - Arguments to filter Deployments to count.
     * @example
     * // Count the number of Deployments
     * const count = await prisma.deployment.count({
     *   where: {
     *     // ... the filter for the Deployments we want to count
     *   }
     * })
    **/
    count<T extends DeploymentCountArgs>(
      args?: Subset<T, DeploymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeploymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeploymentAggregateArgs>(args: Subset<T, DeploymentAggregateArgs>): Prisma.PrismaPromise<GetDeploymentAggregateType<T>>

    /**
     * Group by Deployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeploymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeploymentGroupByArgs['orderBy'] }
        : { orderBy?: DeploymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeploymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deployment model
   */
  readonly fields: DeploymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deployment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeploymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    version<T extends ModelVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelVersionDefaultArgs<ExtArgs>>): Prisma__ModelVersionClient<$Result.GetResult<Prisma.$ModelVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deployment model
   */ 
  interface DeploymentFieldRefs {
    readonly id: FieldRef<"Deployment", 'String'>
    readonly modelId: FieldRef<"Deployment", 'String'>
    readonly versionId: FieldRef<"Deployment", 'String'>
    readonly environment: FieldRef<"Deployment", 'String'>
    readonly status: FieldRef<"Deployment", 'DeploymentStatus'>
    readonly metrics: FieldRef<"Deployment", 'Json'>
    readonly config: FieldRef<"Deployment", 'Json'>
    readonly createdAt: FieldRef<"Deployment", 'DateTime'>
    readonly updatedAt: FieldRef<"Deployment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deployment findUnique
   */
  export type DeploymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment findUniqueOrThrow
   */
  export type DeploymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment findFirst
   */
  export type DeploymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deployments.
     */
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment findFirstOrThrow
   */
  export type DeploymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deployments.
     */
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment findMany
   */
  export type DeploymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployments to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment create
   */
  export type DeploymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Deployment.
     */
    data: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
  }

  /**
   * Deployment createMany
   */
  export type DeploymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deployments.
     */
    data: DeploymentCreateManyInput | DeploymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deployment createManyAndReturn
   */
  export type DeploymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deployments.
     */
    data: DeploymentCreateManyInput | DeploymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deployment update
   */
  export type DeploymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Deployment.
     */
    data: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
    /**
     * Choose, which Deployment to update.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment updateMany
   */
  export type DeploymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deployments.
     */
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyInput>
    /**
     * Filter which Deployments to update
     */
    where?: DeploymentWhereInput
  }

  /**
   * Deployment upsert
   */
  export type DeploymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Deployment to update in case it exists.
     */
    where: DeploymentWhereUniqueInput
    /**
     * In case the Deployment found by the `where` argument doesn't exist, create a new Deployment with this data.
     */
    create: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
    /**
     * In case the Deployment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
  }

  /**
   * Deployment delete
   */
  export type DeploymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter which Deployment to delete.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment deleteMany
   */
  export type DeploymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deployments to delete
     */
    where?: DeploymentWhereInput
  }

  /**
   * Deployment without action
   */
  export type DeploymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    avatar: 'avatar',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const ModelCollaboratorScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelCollaboratorScalarFieldEnum = (typeof ModelCollaboratorScalarFieldEnum)[keyof typeof ModelCollaboratorScalarFieldEnum]


  export const ModelVersionScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    version: 'version',
    metrics: 'metrics',
    artifacts: 'artifacts',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelVersionScalarFieldEnum = (typeof ModelVersionScalarFieldEnum)[keyof typeof ModelVersionScalarFieldEnum]


  export const ChangeScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    userId: 'userId',
    type: 'type',
    content: 'content',
    diff: 'diff',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChangeScalarFieldEnum = (typeof ChangeScalarFieldEnum)[keyof typeof ChangeScalarFieldEnum]


  export const ChangeReviewerScalarFieldEnum: {
    id: 'id',
    changeId: 'changeId',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChangeReviewerScalarFieldEnum = (typeof ChangeReviewerScalarFieldEnum)[keyof typeof ChangeReviewerScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    changeId: 'changeId',
    userId: 'userId',
    content: 'content',
    file: 'file',
    line: 'line',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommentReactionScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type CommentReactionScalarFieldEnum = (typeof CommentReactionScalarFieldEnum)[keyof typeof CommentReactionScalarFieldEnum]


  export const DeploymentScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    versionId: 'versionId',
    environment: 'environment',
    status: 'status',
    metrics: 'metrics',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeploymentScalarFieldEnum = (typeof DeploymentScalarFieldEnum)[keyof typeof DeploymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ModelStatus'
   */
  export type EnumModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelStatus'>
    


  /**
   * Reference to a field of type 'ModelStatus[]'
   */
  export type ListEnumModelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelStatus[]'>
    


  /**
   * Reference to a field of type 'CollaboratorRole'
   */
  export type EnumCollaboratorRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollaboratorRole'>
    


  /**
   * Reference to a field of type 'CollaboratorRole[]'
   */
  export type ListEnumCollaboratorRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollaboratorRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'VersionStatus'
   */
  export type EnumVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VersionStatus'>
    


  /**
   * Reference to a field of type 'VersionStatus[]'
   */
  export type ListEnumVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VersionStatus[]'>
    


  /**
   * Reference to a field of type 'ChangeType'
   */
  export type EnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType'>
    


  /**
   * Reference to a field of type 'ChangeType[]'
   */
  export type ListEnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType[]'>
    


  /**
   * Reference to a field of type 'ChangeStatus'
   */
  export type EnumChangeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeStatus'>
    


  /**
   * Reference to a field of type 'ChangeStatus[]'
   */
  export type ListEnumChangeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeStatus[]'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DeploymentStatus'
   */
  export type EnumDeploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeploymentStatus'>
    


  /**
   * Reference to a field of type 'DeploymentStatus[]'
   */
  export type ListEnumDeploymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeploymentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    models?: ModelListRelationFilter
    collaborations?: ModelCollaboratorListRelationFilter
    changes?: ChangeListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    models?: ModelOrderByRelationAggregateInput
    collaborations?: ModelCollaboratorOrderByRelationAggregateInput
    changes?: ChangeOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    models?: ModelListRelationFilter
    collaborations?: ModelCollaboratorListRelationFilter
    changes?: ChangeListRelationFilter
    comments?: CommentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: StringFilter<"Model"> | string
    name?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    ownerId?: StringFilter<"Model"> | string
    status?: EnumModelStatusFilter<"Model"> | $Enums.ModelStatus
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    collaborators?: ModelCollaboratorListRelationFilter
    versions?: ModelVersionListRelationFilter
    changes?: ChangeListRelationFilter
    deployments?: DeploymentListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    collaborators?: ModelCollaboratorOrderByRelationAggregateInput
    versions?: ModelVersionOrderByRelationAggregateInput
    changes?: ChangeOrderByRelationAggregateInput
    deployments?: DeploymentOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    name?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    ownerId?: StringFilter<"Model"> | string
    status?: EnumModelStatusFilter<"Model"> | $Enums.ModelStatus
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    collaborators?: ModelCollaboratorListRelationFilter
    versions?: ModelVersionListRelationFilter
    changes?: ChangeListRelationFilter
    deployments?: DeploymentListRelationFilter
  }, "id">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Model"> | string
    name?: StringWithAggregatesFilter<"Model"> | string
    description?: StringNullableWithAggregatesFilter<"Model"> | string | null
    ownerId?: StringWithAggregatesFilter<"Model"> | string
    status?: EnumModelStatusWithAggregatesFilter<"Model"> | $Enums.ModelStatus
    createdAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
  }

  export type ModelCollaboratorWhereInput = {
    AND?: ModelCollaboratorWhereInput | ModelCollaboratorWhereInput[]
    OR?: ModelCollaboratorWhereInput[]
    NOT?: ModelCollaboratorWhereInput | ModelCollaboratorWhereInput[]
    id?: StringFilter<"ModelCollaborator"> | string
    modelId?: StringFilter<"ModelCollaborator"> | string
    userId?: StringFilter<"ModelCollaborator"> | string
    role?: EnumCollaboratorRoleFilter<"ModelCollaborator"> | $Enums.CollaboratorRole
    createdAt?: DateTimeFilter<"ModelCollaborator"> | Date | string
    updatedAt?: DateTimeFilter<"ModelCollaborator"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ModelCollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: ModelOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ModelCollaboratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    modelId_userId?: ModelCollaboratorModelIdUserIdCompoundUniqueInput
    AND?: ModelCollaboratorWhereInput | ModelCollaboratorWhereInput[]
    OR?: ModelCollaboratorWhereInput[]
    NOT?: ModelCollaboratorWhereInput | ModelCollaboratorWhereInput[]
    modelId?: StringFilter<"ModelCollaborator"> | string
    userId?: StringFilter<"ModelCollaborator"> | string
    role?: EnumCollaboratorRoleFilter<"ModelCollaborator"> | $Enums.CollaboratorRole
    createdAt?: DateTimeFilter<"ModelCollaborator"> | Date | string
    updatedAt?: DateTimeFilter<"ModelCollaborator"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "modelId_userId">

  export type ModelCollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelCollaboratorCountOrderByAggregateInput
    _max?: ModelCollaboratorMaxOrderByAggregateInput
    _min?: ModelCollaboratorMinOrderByAggregateInput
  }

  export type ModelCollaboratorScalarWhereWithAggregatesInput = {
    AND?: ModelCollaboratorScalarWhereWithAggregatesInput | ModelCollaboratorScalarWhereWithAggregatesInput[]
    OR?: ModelCollaboratorScalarWhereWithAggregatesInput[]
    NOT?: ModelCollaboratorScalarWhereWithAggregatesInput | ModelCollaboratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelCollaborator"> | string
    modelId?: StringWithAggregatesFilter<"ModelCollaborator"> | string
    userId?: StringWithAggregatesFilter<"ModelCollaborator"> | string
    role?: EnumCollaboratorRoleWithAggregatesFilter<"ModelCollaborator"> | $Enums.CollaboratorRole
    createdAt?: DateTimeWithAggregatesFilter<"ModelCollaborator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModelCollaborator"> | Date | string
  }

  export type ModelVersionWhereInput = {
    AND?: ModelVersionWhereInput | ModelVersionWhereInput[]
    OR?: ModelVersionWhereInput[]
    NOT?: ModelVersionWhereInput | ModelVersionWhereInput[]
    id?: StringFilter<"ModelVersion"> | string
    modelId?: StringFilter<"ModelVersion"> | string
    version?: StringFilter<"ModelVersion"> | string
    metrics?: JsonNullableFilter<"ModelVersion">
    artifacts?: JsonFilter<"ModelVersion">
    status?: EnumVersionStatusFilter<"ModelVersion"> | $Enums.VersionStatus
    createdAt?: DateTimeFilter<"ModelVersion"> | Date | string
    updatedAt?: DateTimeFilter<"ModelVersion"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    deployments?: DeploymentListRelationFilter
  }

  export type ModelVersionOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    version?: SortOrder
    metrics?: SortOrderInput | SortOrder
    artifacts?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: ModelOrderByWithRelationInput
    deployments?: DeploymentOrderByRelationAggregateInput
  }

  export type ModelVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModelVersionWhereInput | ModelVersionWhereInput[]
    OR?: ModelVersionWhereInput[]
    NOT?: ModelVersionWhereInput | ModelVersionWhereInput[]
    modelId?: StringFilter<"ModelVersion"> | string
    version?: StringFilter<"ModelVersion"> | string
    metrics?: JsonNullableFilter<"ModelVersion">
    artifacts?: JsonFilter<"ModelVersion">
    status?: EnumVersionStatusFilter<"ModelVersion"> | $Enums.VersionStatus
    createdAt?: DateTimeFilter<"ModelVersion"> | Date | string
    updatedAt?: DateTimeFilter<"ModelVersion"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    deployments?: DeploymentListRelationFilter
  }, "id">

  export type ModelVersionOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    version?: SortOrder
    metrics?: SortOrderInput | SortOrder
    artifacts?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelVersionCountOrderByAggregateInput
    _max?: ModelVersionMaxOrderByAggregateInput
    _min?: ModelVersionMinOrderByAggregateInput
  }

  export type ModelVersionScalarWhereWithAggregatesInput = {
    AND?: ModelVersionScalarWhereWithAggregatesInput | ModelVersionScalarWhereWithAggregatesInput[]
    OR?: ModelVersionScalarWhereWithAggregatesInput[]
    NOT?: ModelVersionScalarWhereWithAggregatesInput | ModelVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModelVersion"> | string
    modelId?: StringWithAggregatesFilter<"ModelVersion"> | string
    version?: StringWithAggregatesFilter<"ModelVersion"> | string
    metrics?: JsonNullableWithAggregatesFilter<"ModelVersion">
    artifacts?: JsonWithAggregatesFilter<"ModelVersion">
    status?: EnumVersionStatusWithAggregatesFilter<"ModelVersion"> | $Enums.VersionStatus
    createdAt?: DateTimeWithAggregatesFilter<"ModelVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModelVersion"> | Date | string
  }

  export type ChangeWhereInput = {
    AND?: ChangeWhereInput | ChangeWhereInput[]
    OR?: ChangeWhereInput[]
    NOT?: ChangeWhereInput | ChangeWhereInput[]
    id?: StringFilter<"Change"> | string
    modelId?: StringFilter<"Change"> | string
    userId?: StringFilter<"Change"> | string
    type?: EnumChangeTypeFilter<"Change"> | $Enums.ChangeType
    content?: StringFilter<"Change"> | string
    diff?: StringNullableFilter<"Change"> | string | null
    description?: StringFilter<"Change"> | string
    status?: EnumChangeStatusFilter<"Change"> | $Enums.ChangeStatus
    createdAt?: DateTimeFilter<"Change"> | Date | string
    updatedAt?: DateTimeFilter<"Change"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    reviewers?: ChangeReviewerListRelationFilter
  }

  export type ChangeOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    diff?: SortOrderInput | SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: ModelOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    reviewers?: ChangeReviewerOrderByRelationAggregateInput
  }

  export type ChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChangeWhereInput | ChangeWhereInput[]
    OR?: ChangeWhereInput[]
    NOT?: ChangeWhereInput | ChangeWhereInput[]
    modelId?: StringFilter<"Change"> | string
    userId?: StringFilter<"Change"> | string
    type?: EnumChangeTypeFilter<"Change"> | $Enums.ChangeType
    content?: StringFilter<"Change"> | string
    diff?: StringNullableFilter<"Change"> | string | null
    description?: StringFilter<"Change"> | string
    status?: EnumChangeStatusFilter<"Change"> | $Enums.ChangeStatus
    createdAt?: DateTimeFilter<"Change"> | Date | string
    updatedAt?: DateTimeFilter<"Change"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    reviewers?: ChangeReviewerListRelationFilter
  }, "id">

  export type ChangeOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    diff?: SortOrderInput | SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChangeCountOrderByAggregateInput
    _max?: ChangeMaxOrderByAggregateInput
    _min?: ChangeMinOrderByAggregateInput
  }

  export type ChangeScalarWhereWithAggregatesInput = {
    AND?: ChangeScalarWhereWithAggregatesInput | ChangeScalarWhereWithAggregatesInput[]
    OR?: ChangeScalarWhereWithAggregatesInput[]
    NOT?: ChangeScalarWhereWithAggregatesInput | ChangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Change"> | string
    modelId?: StringWithAggregatesFilter<"Change"> | string
    userId?: StringWithAggregatesFilter<"Change"> | string
    type?: EnumChangeTypeWithAggregatesFilter<"Change"> | $Enums.ChangeType
    content?: StringWithAggregatesFilter<"Change"> | string
    diff?: StringNullableWithAggregatesFilter<"Change"> | string | null
    description?: StringWithAggregatesFilter<"Change"> | string
    status?: EnumChangeStatusWithAggregatesFilter<"Change"> | $Enums.ChangeStatus
    createdAt?: DateTimeWithAggregatesFilter<"Change"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Change"> | Date | string
  }

  export type ChangeReviewerWhereInput = {
    AND?: ChangeReviewerWhereInput | ChangeReviewerWhereInput[]
    OR?: ChangeReviewerWhereInput[]
    NOT?: ChangeReviewerWhereInput | ChangeReviewerWhereInput[]
    id?: StringFilter<"ChangeReviewer"> | string
    changeId?: StringFilter<"ChangeReviewer"> | string
    userId?: StringFilter<"ChangeReviewer"> | string
    status?: EnumReviewStatusFilter<"ChangeReviewer"> | $Enums.ReviewStatus
    createdAt?: DateTimeFilter<"ChangeReviewer"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeReviewer"> | Date | string
    change?: XOR<ChangeRelationFilter, ChangeWhereInput>
  }

  export type ChangeReviewerOrderByWithRelationInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    change?: ChangeOrderByWithRelationInput
  }

  export type ChangeReviewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    changeId_userId?: ChangeReviewerChangeIdUserIdCompoundUniqueInput
    AND?: ChangeReviewerWhereInput | ChangeReviewerWhereInput[]
    OR?: ChangeReviewerWhereInput[]
    NOT?: ChangeReviewerWhereInput | ChangeReviewerWhereInput[]
    changeId?: StringFilter<"ChangeReviewer"> | string
    userId?: StringFilter<"ChangeReviewer"> | string
    status?: EnumReviewStatusFilter<"ChangeReviewer"> | $Enums.ReviewStatus
    createdAt?: DateTimeFilter<"ChangeReviewer"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeReviewer"> | Date | string
    change?: XOR<ChangeRelationFilter, ChangeWhereInput>
  }, "id" | "changeId_userId">

  export type ChangeReviewerOrderByWithAggregationInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChangeReviewerCountOrderByAggregateInput
    _max?: ChangeReviewerMaxOrderByAggregateInput
    _min?: ChangeReviewerMinOrderByAggregateInput
  }

  export type ChangeReviewerScalarWhereWithAggregatesInput = {
    AND?: ChangeReviewerScalarWhereWithAggregatesInput | ChangeReviewerScalarWhereWithAggregatesInput[]
    OR?: ChangeReviewerScalarWhereWithAggregatesInput[]
    NOT?: ChangeReviewerScalarWhereWithAggregatesInput | ChangeReviewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChangeReviewer"> | string
    changeId?: StringWithAggregatesFilter<"ChangeReviewer"> | string
    userId?: StringWithAggregatesFilter<"ChangeReviewer"> | string
    status?: EnumReviewStatusWithAggregatesFilter<"ChangeReviewer"> | $Enums.ReviewStatus
    createdAt?: DateTimeWithAggregatesFilter<"ChangeReviewer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChangeReviewer"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    changeId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    file?: StringNullableFilter<"Comment"> | string | null
    line?: IntNullableFilter<"Comment"> | number | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    change?: XOR<ChangeRelationFilter, ChangeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    reactions?: CommentReactionListRelationFilter
    replies?: CommentListRelationFilter
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    file?: SortOrderInput | SortOrder
    line?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    change?: ChangeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    reactions?: CommentReactionOrderByRelationAggregateInput
    replies?: CommentOrderByRelationAggregateInput
    parent?: CommentOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    changeId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    file?: StringNullableFilter<"Comment"> | string | null
    line?: IntNullableFilter<"Comment"> | number | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    change?: XOR<ChangeRelationFilter, ChangeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    reactions?: CommentReactionListRelationFilter
    replies?: CommentListRelationFilter
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    file?: SortOrderInput | SortOrder
    line?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    changeId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    file?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    line?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type CommentReactionWhereInput = {
    AND?: CommentReactionWhereInput | CommentReactionWhereInput[]
    OR?: CommentReactionWhereInput[]
    NOT?: CommentReactionWhereInput | CommentReactionWhereInput[]
    id?: StringFilter<"CommentReaction"> | string
    commentId?: StringFilter<"CommentReaction"> | string
    userId?: StringFilter<"CommentReaction"> | string
    type?: StringFilter<"CommentReaction"> | string
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type CommentReactionOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
  }

  export type CommentReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commentId_userId_type?: CommentReactionCommentIdUserIdTypeCompoundUniqueInput
    AND?: CommentReactionWhereInput | CommentReactionWhereInput[]
    OR?: CommentReactionWhereInput[]
    NOT?: CommentReactionWhereInput | CommentReactionWhereInput[]
    commentId?: StringFilter<"CommentReaction"> | string
    userId?: StringFilter<"CommentReaction"> | string
    type?: StringFilter<"CommentReaction"> | string
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }, "id" | "commentId_userId_type">

  export type CommentReactionOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: CommentReactionCountOrderByAggregateInput
    _max?: CommentReactionMaxOrderByAggregateInput
    _min?: CommentReactionMinOrderByAggregateInput
  }

  export type CommentReactionScalarWhereWithAggregatesInput = {
    AND?: CommentReactionScalarWhereWithAggregatesInput | CommentReactionScalarWhereWithAggregatesInput[]
    OR?: CommentReactionScalarWhereWithAggregatesInput[]
    NOT?: CommentReactionScalarWhereWithAggregatesInput | CommentReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentReaction"> | string
    commentId?: StringWithAggregatesFilter<"CommentReaction"> | string
    userId?: StringWithAggregatesFilter<"CommentReaction"> | string
    type?: StringWithAggregatesFilter<"CommentReaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommentReaction"> | Date | string
  }

  export type DeploymentWhereInput = {
    AND?: DeploymentWhereInput | DeploymentWhereInput[]
    OR?: DeploymentWhereInput[]
    NOT?: DeploymentWhereInput | DeploymentWhereInput[]
    id?: StringFilter<"Deployment"> | string
    modelId?: StringFilter<"Deployment"> | string
    versionId?: StringFilter<"Deployment"> | string
    environment?: StringFilter<"Deployment"> | string
    status?: EnumDeploymentStatusFilter<"Deployment"> | $Enums.DeploymentStatus
    metrics?: JsonNullableFilter<"Deployment">
    config?: JsonFilter<"Deployment">
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    version?: XOR<ModelVersionRelationFilter, ModelVersionWhereInput>
  }

  export type DeploymentOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    environment?: SortOrder
    status?: SortOrder
    metrics?: SortOrderInput | SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: ModelOrderByWithRelationInput
    version?: ModelVersionOrderByWithRelationInput
  }

  export type DeploymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeploymentWhereInput | DeploymentWhereInput[]
    OR?: DeploymentWhereInput[]
    NOT?: DeploymentWhereInput | DeploymentWhereInput[]
    modelId?: StringFilter<"Deployment"> | string
    versionId?: StringFilter<"Deployment"> | string
    environment?: StringFilter<"Deployment"> | string
    status?: EnumDeploymentStatusFilter<"Deployment"> | $Enums.DeploymentStatus
    metrics?: JsonNullableFilter<"Deployment">
    config?: JsonFilter<"Deployment">
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
    model?: XOR<ModelRelationFilter, ModelWhereInput>
    version?: XOR<ModelVersionRelationFilter, ModelVersionWhereInput>
  }, "id">

  export type DeploymentOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    environment?: SortOrder
    status?: SortOrder
    metrics?: SortOrderInput | SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeploymentCountOrderByAggregateInput
    _max?: DeploymentMaxOrderByAggregateInput
    _min?: DeploymentMinOrderByAggregateInput
  }

  export type DeploymentScalarWhereWithAggregatesInput = {
    AND?: DeploymentScalarWhereWithAggregatesInput | DeploymentScalarWhereWithAggregatesInput[]
    OR?: DeploymentScalarWhereWithAggregatesInput[]
    NOT?: DeploymentScalarWhereWithAggregatesInput | DeploymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deployment"> | string
    modelId?: StringWithAggregatesFilter<"Deployment"> | string
    versionId?: StringWithAggregatesFilter<"Deployment"> | string
    environment?: StringWithAggregatesFilter<"Deployment"> | string
    status?: EnumDeploymentStatusWithAggregatesFilter<"Deployment"> | $Enums.DeploymentStatus
    metrics?: JsonNullableWithAggregatesFilter<"Deployment">
    config?: JsonWithAggregatesFilter<"Deployment">
    createdAt?: DateTimeWithAggregatesFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deployment"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelCreateNestedManyWithoutOwnerInput
    collaborations?: ModelCollaboratorCreateNestedManyWithoutUserInput
    changes?: ChangeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelUncheckedCreateNestedManyWithoutOwnerInput
    collaborations?: ModelCollaboratorUncheckedCreateNestedManyWithoutUserInput
    changes?: ChangeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUpdateManyWithoutOwnerNestedInput
    collaborations?: ModelCollaboratorUpdateManyWithoutUserNestedInput
    changes?: ChangeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUncheckedUpdateManyWithoutOwnerNestedInput
    collaborations?: ModelCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutModelsInput
    collaborators?: ModelCollaboratorCreateNestedManyWithoutModelInput
    versions?: ModelVersionCreateNestedManyWithoutModelInput
    changes?: ChangeCreateNestedManyWithoutModelInput
    deployments?: DeploymentCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ModelCollaboratorUncheckedCreateNestedManyWithoutModelInput
    versions?: ModelVersionUncheckedCreateNestedManyWithoutModelInput
    changes?: ChangeUncheckedCreateNestedManyWithoutModelInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutModelsNestedInput
    collaborators?: ModelCollaboratorUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUpdateManyWithoutModelNestedInput
    changes?: ChangeUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ModelCollaboratorUncheckedUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUncheckedUpdateManyWithoutModelNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCollaboratorCreateInput = {
    id?: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutCollaboratorsInput
    user: UserCreateNestedOneWithoutCollaborationsInput
  }

  export type ModelCollaboratorUncheckedCreateInput = {
    id?: string
    modelId: string
    userId: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutCollaboratorsNestedInput
    user?: UserUpdateOneRequiredWithoutCollaborationsNestedInput
  }

  export type ModelCollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCollaboratorCreateManyInput = {
    id?: string
    modelId: string
    userId: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelVersionCreateInput = {
    id?: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutVersionsInput
    deployments?: DeploymentCreateNestedManyWithoutVersionInput
  }

  export type ModelVersionUncheckedCreateInput = {
    id?: string
    modelId: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deployments?: DeploymentUncheckedCreateNestedManyWithoutVersionInput
  }

  export type ModelVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutVersionsNestedInput
    deployments?: DeploymentUpdateManyWithoutVersionNestedInput
  }

  export type ModelVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployments?: DeploymentUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type ModelVersionCreateManyInput = {
    id?: string
    modelId: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeCreateInput = {
    id?: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutChangesInput
    user: UserCreateNestedOneWithoutChangesInput
    comments?: CommentCreateNestedManyWithoutChangeInput
    reviewers?: ChangeReviewerCreateNestedManyWithoutChangeInput
  }

  export type ChangeUncheckedCreateInput = {
    id?: string
    modelId: string
    userId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChangeInput
    reviewers?: ChangeReviewerUncheckedCreateNestedManyWithoutChangeInput
  }

  export type ChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutChangesNestedInput
    user?: UserUpdateOneRequiredWithoutChangesNestedInput
    comments?: CommentUpdateManyWithoutChangeNestedInput
    reviewers?: ChangeReviewerUpdateManyWithoutChangeNestedInput
  }

  export type ChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChangeNestedInput
    reviewers?: ChangeReviewerUncheckedUpdateManyWithoutChangeNestedInput
  }

  export type ChangeCreateManyInput = {
    id?: string
    modelId: string
    userId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeReviewerCreateInput = {
    id?: string
    userId: string
    status?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    change: ChangeCreateNestedOneWithoutReviewersInput
  }

  export type ChangeReviewerUncheckedCreateInput = {
    id?: string
    changeId: string
    userId: string
    status?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeReviewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    change?: ChangeUpdateOneRequiredWithoutReviewersNestedInput
  }

  export type ChangeReviewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeReviewerCreateManyInput = {
    id?: string
    changeId: string
    userId: string
    status?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeReviewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeReviewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    change: ChangeCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    replies?: CommentCreateNestedManyWithoutParentInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    changeId: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    change?: ChangeUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    changeId: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentReactionCreateInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutReactionsInput
  }

  export type CommentReactionUncheckedCreateInput = {
    id?: string
    commentId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type CommentReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionCreateManyInput = {
    id?: string
    commentId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentCreateInput = {
    id?: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutDeploymentsInput
    version: ModelVersionCreateNestedOneWithoutDeploymentsInput
  }

  export type DeploymentUncheckedCreateInput = {
    id?: string
    modelId: string
    versionId: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutDeploymentsNestedInput
    version?: ModelVersionUpdateOneRequiredWithoutDeploymentsNestedInput
  }

  export type DeploymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentCreateManyInput = {
    id?: string
    modelId: string
    versionId: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ModelListRelationFilter = {
    every?: ModelWhereInput
    some?: ModelWhereInput
    none?: ModelWhereInput
  }

  export type ModelCollaboratorListRelationFilter = {
    every?: ModelCollaboratorWhereInput
    some?: ModelCollaboratorWhereInput
    none?: ModelCollaboratorWhereInput
  }

  export type ChangeListRelationFilter = {
    every?: ChangeWhereInput
    some?: ChangeWhereInput
    none?: ChangeWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelCollaboratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusFilter<$PrismaModel> | $Enums.ModelStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ModelVersionListRelationFilter = {
    every?: ModelVersionWhereInput
    some?: ModelVersionWhereInput
    none?: ModelVersionWhereInput
  }

  export type DeploymentListRelationFilter = {
    every?: DeploymentWhereInput
    some?: DeploymentWhereInput
    none?: DeploymentWhereInput
  }

  export type ModelVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeploymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelStatusFilter<$PrismaModel>
    _max?: NestedEnumModelStatusFilter<$PrismaModel>
  }

  export type EnumCollaboratorRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CollaboratorRole | EnumCollaboratorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCollaboratorRoleFilter<$PrismaModel> | $Enums.CollaboratorRole
  }

  export type ModelRelationFilter = {
    is?: ModelWhereInput
    isNot?: ModelWhereInput
  }

  export type ModelCollaboratorModelIdUserIdCompoundUniqueInput = {
    modelId: string
    userId: string
  }

  export type ModelCollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelCollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelCollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCollaboratorRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollaboratorRole | EnumCollaboratorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCollaboratorRoleWithAggregatesFilter<$PrismaModel> | $Enums.CollaboratorRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollaboratorRoleFilter<$PrismaModel>
    _max?: NestedEnumCollaboratorRoleFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VersionStatus | EnumVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVersionStatusFilter<$PrismaModel> | $Enums.VersionStatus
  }

  export type ModelVersionCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    version?: SortOrder
    metrics?: SortOrder
    artifacts?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelVersionMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VersionStatus | EnumVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.VersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumVersionStatusFilter<$PrismaModel>
  }

  export type EnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type EnumChangeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusFilter<$PrismaModel> | $Enums.ChangeStatus
  }

  export type ChangeReviewerListRelationFilter = {
    every?: ChangeReviewerWhereInput
    some?: ChangeReviewerWhereInput
    none?: ChangeReviewerWhereInput
  }

  export type ChangeReviewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    diff?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    diff?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangeMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    diff?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type EnumChangeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChangeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeStatusFilter<$PrismaModel>
    _max?: NestedEnumChangeStatusFilter<$PrismaModel>
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type ChangeRelationFilter = {
    is?: ChangeWhereInput
    isNot?: ChangeWhereInput
  }

  export type ChangeReviewerChangeIdUserIdCompoundUniqueInput = {
    changeId: string
    userId: string
  }

  export type ChangeReviewerCountOrderByAggregateInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangeReviewerMaxOrderByAggregateInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChangeReviewerMinOrderByAggregateInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CommentReactionListRelationFilter = {
    every?: CommentReactionWhereInput
    some?: CommentReactionWhereInput
    none?: CommentReactionWhereInput
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    file?: SortOrder
    line?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    line?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    file?: SortOrder
    line?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    changeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    file?: SortOrder
    line?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    line?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentReactionCommentIdUserIdTypeCompoundUniqueInput = {
    commentId: string
    userId: string
    type: string
  }

  export type CommentReactionCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReactionMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDeploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusFilter<$PrismaModel> | $Enums.DeploymentStatus
  }

  export type ModelVersionRelationFilter = {
    is?: ModelVersionWhereInput
    isNot?: ModelVersionWhereInput
  }

  export type DeploymentCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    environment?: SortOrder
    status?: SortOrder
    metrics?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeploymentMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    environment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeploymentMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    environment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumDeploymentStatusFilter<$PrismaModel>
  }

  export type ModelCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ModelCreateWithoutOwnerInput, ModelUncheckedCreateWithoutOwnerInput> | ModelCreateWithoutOwnerInput[] | ModelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutOwnerInput | ModelCreateOrConnectWithoutOwnerInput[]
    createMany?: ModelCreateManyOwnerInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type ModelCollaboratorCreateNestedManyWithoutUserInput = {
    create?: XOR<ModelCollaboratorCreateWithoutUserInput, ModelCollaboratorUncheckedCreateWithoutUserInput> | ModelCollaboratorCreateWithoutUserInput[] | ModelCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutUserInput | ModelCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: ModelCollaboratorCreateManyUserInputEnvelope
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
  }

  export type ChangeCreateNestedManyWithoutUserInput = {
    create?: XOR<ChangeCreateWithoutUserInput, ChangeUncheckedCreateWithoutUserInput> | ChangeCreateWithoutUserInput[] | ChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutUserInput | ChangeCreateOrConnectWithoutUserInput[]
    createMany?: ChangeCreateManyUserInputEnvelope
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ModelUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ModelCreateWithoutOwnerInput, ModelUncheckedCreateWithoutOwnerInput> | ModelCreateWithoutOwnerInput[] | ModelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutOwnerInput | ModelCreateOrConnectWithoutOwnerInput[]
    createMany?: ModelCreateManyOwnerInputEnvelope
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
  }

  export type ModelCollaboratorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ModelCollaboratorCreateWithoutUserInput, ModelCollaboratorUncheckedCreateWithoutUserInput> | ModelCollaboratorCreateWithoutUserInput[] | ModelCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutUserInput | ModelCollaboratorCreateOrConnectWithoutUserInput[]
    createMany?: ModelCollaboratorCreateManyUserInputEnvelope
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
  }

  export type ChangeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChangeCreateWithoutUserInput, ChangeUncheckedCreateWithoutUserInput> | ChangeCreateWithoutUserInput[] | ChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutUserInput | ChangeCreateOrConnectWithoutUserInput[]
    createMany?: ChangeCreateManyUserInputEnvelope
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ModelUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ModelCreateWithoutOwnerInput, ModelUncheckedCreateWithoutOwnerInput> | ModelCreateWithoutOwnerInput[] | ModelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutOwnerInput | ModelCreateOrConnectWithoutOwnerInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutOwnerInput | ModelUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ModelCreateManyOwnerInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutOwnerInput | ModelUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutOwnerInput | ModelUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type ModelCollaboratorUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModelCollaboratorCreateWithoutUserInput, ModelCollaboratorUncheckedCreateWithoutUserInput> | ModelCollaboratorCreateWithoutUserInput[] | ModelCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutUserInput | ModelCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: ModelCollaboratorUpsertWithWhereUniqueWithoutUserInput | ModelCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModelCollaboratorCreateManyUserInputEnvelope
    set?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    disconnect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    delete?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    update?: ModelCollaboratorUpdateWithWhereUniqueWithoutUserInput | ModelCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModelCollaboratorUpdateManyWithWhereWithoutUserInput | ModelCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModelCollaboratorScalarWhereInput | ModelCollaboratorScalarWhereInput[]
  }

  export type ChangeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChangeCreateWithoutUserInput, ChangeUncheckedCreateWithoutUserInput> | ChangeCreateWithoutUserInput[] | ChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutUserInput | ChangeCreateOrConnectWithoutUserInput[]
    upsert?: ChangeUpsertWithWhereUniqueWithoutUserInput | ChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChangeCreateManyUserInputEnvelope
    set?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    disconnect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    delete?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    update?: ChangeUpdateWithWhereUniqueWithoutUserInput | ChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChangeUpdateManyWithWhereWithoutUserInput | ChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChangeScalarWhereInput | ChangeScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ModelUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ModelCreateWithoutOwnerInput, ModelUncheckedCreateWithoutOwnerInput> | ModelCreateWithoutOwnerInput[] | ModelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ModelCreateOrConnectWithoutOwnerInput | ModelCreateOrConnectWithoutOwnerInput[]
    upsert?: ModelUpsertWithWhereUniqueWithoutOwnerInput | ModelUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ModelCreateManyOwnerInputEnvelope
    set?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    disconnect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    delete?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    connect?: ModelWhereUniqueInput | ModelWhereUniqueInput[]
    update?: ModelUpdateWithWhereUniqueWithoutOwnerInput | ModelUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ModelUpdateManyWithWhereWithoutOwnerInput | ModelUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ModelScalarWhereInput | ModelScalarWhereInput[]
  }

  export type ModelCollaboratorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModelCollaboratorCreateWithoutUserInput, ModelCollaboratorUncheckedCreateWithoutUserInput> | ModelCollaboratorCreateWithoutUserInput[] | ModelCollaboratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutUserInput | ModelCollaboratorCreateOrConnectWithoutUserInput[]
    upsert?: ModelCollaboratorUpsertWithWhereUniqueWithoutUserInput | ModelCollaboratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModelCollaboratorCreateManyUserInputEnvelope
    set?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    disconnect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    delete?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    update?: ModelCollaboratorUpdateWithWhereUniqueWithoutUserInput | ModelCollaboratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModelCollaboratorUpdateManyWithWhereWithoutUserInput | ModelCollaboratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModelCollaboratorScalarWhereInput | ModelCollaboratorScalarWhereInput[]
  }

  export type ChangeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChangeCreateWithoutUserInput, ChangeUncheckedCreateWithoutUserInput> | ChangeCreateWithoutUserInput[] | ChangeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutUserInput | ChangeCreateOrConnectWithoutUserInput[]
    upsert?: ChangeUpsertWithWhereUniqueWithoutUserInput | ChangeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChangeCreateManyUserInputEnvelope
    set?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    disconnect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    delete?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    update?: ChangeUpdateWithWhereUniqueWithoutUserInput | ChangeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChangeUpdateManyWithWhereWithoutUserInput | ChangeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChangeScalarWhereInput | ChangeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutModelsInput = {
    create?: XOR<UserCreateWithoutModelsInput, UserUncheckedCreateWithoutModelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModelsInput
    connect?: UserWhereUniqueInput
  }

  export type ModelCollaboratorCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelCollaboratorCreateWithoutModelInput, ModelCollaboratorUncheckedCreateWithoutModelInput> | ModelCollaboratorCreateWithoutModelInput[] | ModelCollaboratorUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutModelInput | ModelCollaboratorCreateOrConnectWithoutModelInput[]
    createMany?: ModelCollaboratorCreateManyModelInputEnvelope
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
  }

  export type ModelVersionCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelVersionCreateWithoutModelInput, ModelVersionUncheckedCreateWithoutModelInput> | ModelVersionCreateWithoutModelInput[] | ModelVersionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelVersionCreateOrConnectWithoutModelInput | ModelVersionCreateOrConnectWithoutModelInput[]
    createMany?: ModelVersionCreateManyModelInputEnvelope
    connect?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
  }

  export type ChangeCreateNestedManyWithoutModelInput = {
    create?: XOR<ChangeCreateWithoutModelInput, ChangeUncheckedCreateWithoutModelInput> | ChangeCreateWithoutModelInput[] | ChangeUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutModelInput | ChangeCreateOrConnectWithoutModelInput[]
    createMany?: ChangeCreateManyModelInputEnvelope
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
  }

  export type DeploymentCreateNestedManyWithoutModelInput = {
    create?: XOR<DeploymentCreateWithoutModelInput, DeploymentUncheckedCreateWithoutModelInput> | DeploymentCreateWithoutModelInput[] | DeploymentUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutModelInput | DeploymentCreateOrConnectWithoutModelInput[]
    createMany?: DeploymentCreateManyModelInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type ModelCollaboratorUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelCollaboratorCreateWithoutModelInput, ModelCollaboratorUncheckedCreateWithoutModelInput> | ModelCollaboratorCreateWithoutModelInput[] | ModelCollaboratorUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutModelInput | ModelCollaboratorCreateOrConnectWithoutModelInput[]
    createMany?: ModelCollaboratorCreateManyModelInputEnvelope
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
  }

  export type ModelVersionUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<ModelVersionCreateWithoutModelInput, ModelVersionUncheckedCreateWithoutModelInput> | ModelVersionCreateWithoutModelInput[] | ModelVersionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelVersionCreateOrConnectWithoutModelInput | ModelVersionCreateOrConnectWithoutModelInput[]
    createMany?: ModelVersionCreateManyModelInputEnvelope
    connect?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
  }

  export type ChangeUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<ChangeCreateWithoutModelInput, ChangeUncheckedCreateWithoutModelInput> | ChangeCreateWithoutModelInput[] | ChangeUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutModelInput | ChangeCreateOrConnectWithoutModelInput[]
    createMany?: ChangeCreateManyModelInputEnvelope
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
  }

  export type DeploymentUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<DeploymentCreateWithoutModelInput, DeploymentUncheckedCreateWithoutModelInput> | DeploymentCreateWithoutModelInput[] | DeploymentUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutModelInput | DeploymentCreateOrConnectWithoutModelInput[]
    createMany?: DeploymentCreateManyModelInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type EnumModelStatusFieldUpdateOperationsInput = {
    set?: $Enums.ModelStatus
  }

  export type UserUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<UserCreateWithoutModelsInput, UserUncheckedCreateWithoutModelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModelsInput
    upsert?: UserUpsertWithoutModelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModelsInput, UserUpdateWithoutModelsInput>, UserUncheckedUpdateWithoutModelsInput>
  }

  export type ModelCollaboratorUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelCollaboratorCreateWithoutModelInput, ModelCollaboratorUncheckedCreateWithoutModelInput> | ModelCollaboratorCreateWithoutModelInput[] | ModelCollaboratorUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutModelInput | ModelCollaboratorCreateOrConnectWithoutModelInput[]
    upsert?: ModelCollaboratorUpsertWithWhereUniqueWithoutModelInput | ModelCollaboratorUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelCollaboratorCreateManyModelInputEnvelope
    set?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    disconnect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    delete?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    update?: ModelCollaboratorUpdateWithWhereUniqueWithoutModelInput | ModelCollaboratorUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelCollaboratorUpdateManyWithWhereWithoutModelInput | ModelCollaboratorUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelCollaboratorScalarWhereInput | ModelCollaboratorScalarWhereInput[]
  }

  export type ModelVersionUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelVersionCreateWithoutModelInput, ModelVersionUncheckedCreateWithoutModelInput> | ModelVersionCreateWithoutModelInput[] | ModelVersionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelVersionCreateOrConnectWithoutModelInput | ModelVersionCreateOrConnectWithoutModelInput[]
    upsert?: ModelVersionUpsertWithWhereUniqueWithoutModelInput | ModelVersionUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelVersionCreateManyModelInputEnvelope
    set?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    disconnect?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    delete?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    connect?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    update?: ModelVersionUpdateWithWhereUniqueWithoutModelInput | ModelVersionUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelVersionUpdateManyWithWhereWithoutModelInput | ModelVersionUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelVersionScalarWhereInput | ModelVersionScalarWhereInput[]
  }

  export type ChangeUpdateManyWithoutModelNestedInput = {
    create?: XOR<ChangeCreateWithoutModelInput, ChangeUncheckedCreateWithoutModelInput> | ChangeCreateWithoutModelInput[] | ChangeUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutModelInput | ChangeCreateOrConnectWithoutModelInput[]
    upsert?: ChangeUpsertWithWhereUniqueWithoutModelInput | ChangeUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ChangeCreateManyModelInputEnvelope
    set?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    disconnect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    delete?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    update?: ChangeUpdateWithWhereUniqueWithoutModelInput | ChangeUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ChangeUpdateManyWithWhereWithoutModelInput | ChangeUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ChangeScalarWhereInput | ChangeScalarWhereInput[]
  }

  export type DeploymentUpdateManyWithoutModelNestedInput = {
    create?: XOR<DeploymentCreateWithoutModelInput, DeploymentUncheckedCreateWithoutModelInput> | DeploymentCreateWithoutModelInput[] | DeploymentUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutModelInput | DeploymentCreateOrConnectWithoutModelInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutModelInput | DeploymentUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: DeploymentCreateManyModelInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutModelInput | DeploymentUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutModelInput | DeploymentUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type ModelCollaboratorUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelCollaboratorCreateWithoutModelInput, ModelCollaboratorUncheckedCreateWithoutModelInput> | ModelCollaboratorCreateWithoutModelInput[] | ModelCollaboratorUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelCollaboratorCreateOrConnectWithoutModelInput | ModelCollaboratorCreateOrConnectWithoutModelInput[]
    upsert?: ModelCollaboratorUpsertWithWhereUniqueWithoutModelInput | ModelCollaboratorUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelCollaboratorCreateManyModelInputEnvelope
    set?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    disconnect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    delete?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    connect?: ModelCollaboratorWhereUniqueInput | ModelCollaboratorWhereUniqueInput[]
    update?: ModelCollaboratorUpdateWithWhereUniqueWithoutModelInput | ModelCollaboratorUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelCollaboratorUpdateManyWithWhereWithoutModelInput | ModelCollaboratorUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelCollaboratorScalarWhereInput | ModelCollaboratorScalarWhereInput[]
  }

  export type ModelVersionUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<ModelVersionCreateWithoutModelInput, ModelVersionUncheckedCreateWithoutModelInput> | ModelVersionCreateWithoutModelInput[] | ModelVersionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ModelVersionCreateOrConnectWithoutModelInput | ModelVersionCreateOrConnectWithoutModelInput[]
    upsert?: ModelVersionUpsertWithWhereUniqueWithoutModelInput | ModelVersionUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ModelVersionCreateManyModelInputEnvelope
    set?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    disconnect?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    delete?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    connect?: ModelVersionWhereUniqueInput | ModelVersionWhereUniqueInput[]
    update?: ModelVersionUpdateWithWhereUniqueWithoutModelInput | ModelVersionUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ModelVersionUpdateManyWithWhereWithoutModelInput | ModelVersionUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ModelVersionScalarWhereInput | ModelVersionScalarWhereInput[]
  }

  export type ChangeUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<ChangeCreateWithoutModelInput, ChangeUncheckedCreateWithoutModelInput> | ChangeCreateWithoutModelInput[] | ChangeUncheckedCreateWithoutModelInput[]
    connectOrCreate?: ChangeCreateOrConnectWithoutModelInput | ChangeCreateOrConnectWithoutModelInput[]
    upsert?: ChangeUpsertWithWhereUniqueWithoutModelInput | ChangeUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: ChangeCreateManyModelInputEnvelope
    set?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    disconnect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    delete?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    connect?: ChangeWhereUniqueInput | ChangeWhereUniqueInput[]
    update?: ChangeUpdateWithWhereUniqueWithoutModelInput | ChangeUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: ChangeUpdateManyWithWhereWithoutModelInput | ChangeUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: ChangeScalarWhereInput | ChangeScalarWhereInput[]
  }

  export type DeploymentUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<DeploymentCreateWithoutModelInput, DeploymentUncheckedCreateWithoutModelInput> | DeploymentCreateWithoutModelInput[] | DeploymentUncheckedCreateWithoutModelInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutModelInput | DeploymentCreateOrConnectWithoutModelInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutModelInput | DeploymentUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: DeploymentCreateManyModelInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutModelInput | DeploymentUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutModelInput | DeploymentUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type ModelCreateNestedOneWithoutCollaboratorsInput = {
    create?: XOR<ModelCreateWithoutCollaboratorsInput, ModelUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutCollaboratorsInput
    connect?: ModelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCollaborationsInput = {
    create?: XOR<UserCreateWithoutCollaborationsInput, UserUncheckedCreateWithoutCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollaborationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCollaboratorRoleFieldUpdateOperationsInput = {
    set?: $Enums.CollaboratorRole
  }

  export type ModelUpdateOneRequiredWithoutCollaboratorsNestedInput = {
    create?: XOR<ModelCreateWithoutCollaboratorsInput, ModelUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutCollaboratorsInput
    upsert?: ModelUpsertWithoutCollaboratorsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutCollaboratorsInput, ModelUpdateWithoutCollaboratorsInput>, ModelUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type UserUpdateOneRequiredWithoutCollaborationsNestedInput = {
    create?: XOR<UserCreateWithoutCollaborationsInput, UserUncheckedCreateWithoutCollaborationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollaborationsInput
    upsert?: UserUpsertWithoutCollaborationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCollaborationsInput, UserUpdateWithoutCollaborationsInput>, UserUncheckedUpdateWithoutCollaborationsInput>
  }

  export type ModelCreateNestedOneWithoutVersionsInput = {
    create?: XOR<ModelCreateWithoutVersionsInput, ModelUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutVersionsInput
    connect?: ModelWhereUniqueInput
  }

  export type DeploymentCreateNestedManyWithoutVersionInput = {
    create?: XOR<DeploymentCreateWithoutVersionInput, DeploymentUncheckedCreateWithoutVersionInput> | DeploymentCreateWithoutVersionInput[] | DeploymentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutVersionInput | DeploymentCreateOrConnectWithoutVersionInput[]
    createMany?: DeploymentCreateManyVersionInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type DeploymentUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<DeploymentCreateWithoutVersionInput, DeploymentUncheckedCreateWithoutVersionInput> | DeploymentCreateWithoutVersionInput[] | DeploymentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutVersionInput | DeploymentCreateOrConnectWithoutVersionInput[]
    createMany?: DeploymentCreateManyVersionInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type EnumVersionStatusFieldUpdateOperationsInput = {
    set?: $Enums.VersionStatus
  }

  export type ModelUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<ModelCreateWithoutVersionsInput, ModelUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutVersionsInput
    upsert?: ModelUpsertWithoutVersionsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutVersionsInput, ModelUpdateWithoutVersionsInput>, ModelUncheckedUpdateWithoutVersionsInput>
  }

  export type DeploymentUpdateManyWithoutVersionNestedInput = {
    create?: XOR<DeploymentCreateWithoutVersionInput, DeploymentUncheckedCreateWithoutVersionInput> | DeploymentCreateWithoutVersionInput[] | DeploymentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutVersionInput | DeploymentCreateOrConnectWithoutVersionInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutVersionInput | DeploymentUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: DeploymentCreateManyVersionInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutVersionInput | DeploymentUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutVersionInput | DeploymentUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type DeploymentUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<DeploymentCreateWithoutVersionInput, DeploymentUncheckedCreateWithoutVersionInput> | DeploymentCreateWithoutVersionInput[] | DeploymentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutVersionInput | DeploymentCreateOrConnectWithoutVersionInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutVersionInput | DeploymentUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: DeploymentCreateManyVersionInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutVersionInput | DeploymentUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutVersionInput | DeploymentUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type ModelCreateNestedOneWithoutChangesInput = {
    create?: XOR<ModelCreateWithoutChangesInput, ModelUncheckedCreateWithoutChangesInput>
    connectOrCreate?: ModelCreateOrConnectWithoutChangesInput
    connect?: ModelWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChangesInput = {
    create?: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutChangeInput = {
    create?: XOR<CommentCreateWithoutChangeInput, CommentUncheckedCreateWithoutChangeInput> | CommentCreateWithoutChangeInput[] | CommentUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChangeInput | CommentCreateOrConnectWithoutChangeInput[]
    createMany?: CommentCreateManyChangeInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ChangeReviewerCreateNestedManyWithoutChangeInput = {
    create?: XOR<ChangeReviewerCreateWithoutChangeInput, ChangeReviewerUncheckedCreateWithoutChangeInput> | ChangeReviewerCreateWithoutChangeInput[] | ChangeReviewerUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: ChangeReviewerCreateOrConnectWithoutChangeInput | ChangeReviewerCreateOrConnectWithoutChangeInput[]
    createMany?: ChangeReviewerCreateManyChangeInputEnvelope
    connect?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutChangeInput = {
    create?: XOR<CommentCreateWithoutChangeInput, CommentUncheckedCreateWithoutChangeInput> | CommentCreateWithoutChangeInput[] | CommentUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChangeInput | CommentCreateOrConnectWithoutChangeInput[]
    createMany?: CommentCreateManyChangeInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ChangeReviewerUncheckedCreateNestedManyWithoutChangeInput = {
    create?: XOR<ChangeReviewerCreateWithoutChangeInput, ChangeReviewerUncheckedCreateWithoutChangeInput> | ChangeReviewerCreateWithoutChangeInput[] | ChangeReviewerUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: ChangeReviewerCreateOrConnectWithoutChangeInput | ChangeReviewerCreateOrConnectWithoutChangeInput[]
    createMany?: ChangeReviewerCreateManyChangeInputEnvelope
    connect?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
  }

  export type EnumChangeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChangeType
  }

  export type EnumChangeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChangeStatus
  }

  export type ModelUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<ModelCreateWithoutChangesInput, ModelUncheckedCreateWithoutChangesInput>
    connectOrCreate?: ModelCreateOrConnectWithoutChangesInput
    upsert?: ModelUpsertWithoutChangesInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutChangesInput, ModelUpdateWithoutChangesInput>, ModelUncheckedUpdateWithoutChangesInput>
  }

  export type UserUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangesInput
    upsert?: UserUpsertWithoutChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChangesInput, UserUpdateWithoutChangesInput>, UserUncheckedUpdateWithoutChangesInput>
  }

  export type CommentUpdateManyWithoutChangeNestedInput = {
    create?: XOR<CommentCreateWithoutChangeInput, CommentUncheckedCreateWithoutChangeInput> | CommentCreateWithoutChangeInput[] | CommentUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChangeInput | CommentCreateOrConnectWithoutChangeInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutChangeInput | CommentUpsertWithWhereUniqueWithoutChangeInput[]
    createMany?: CommentCreateManyChangeInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutChangeInput | CommentUpdateWithWhereUniqueWithoutChangeInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutChangeInput | CommentUpdateManyWithWhereWithoutChangeInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ChangeReviewerUpdateManyWithoutChangeNestedInput = {
    create?: XOR<ChangeReviewerCreateWithoutChangeInput, ChangeReviewerUncheckedCreateWithoutChangeInput> | ChangeReviewerCreateWithoutChangeInput[] | ChangeReviewerUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: ChangeReviewerCreateOrConnectWithoutChangeInput | ChangeReviewerCreateOrConnectWithoutChangeInput[]
    upsert?: ChangeReviewerUpsertWithWhereUniqueWithoutChangeInput | ChangeReviewerUpsertWithWhereUniqueWithoutChangeInput[]
    createMany?: ChangeReviewerCreateManyChangeInputEnvelope
    set?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    disconnect?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    delete?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    connect?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    update?: ChangeReviewerUpdateWithWhereUniqueWithoutChangeInput | ChangeReviewerUpdateWithWhereUniqueWithoutChangeInput[]
    updateMany?: ChangeReviewerUpdateManyWithWhereWithoutChangeInput | ChangeReviewerUpdateManyWithWhereWithoutChangeInput[]
    deleteMany?: ChangeReviewerScalarWhereInput | ChangeReviewerScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutChangeNestedInput = {
    create?: XOR<CommentCreateWithoutChangeInput, CommentUncheckedCreateWithoutChangeInput> | CommentCreateWithoutChangeInput[] | CommentUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChangeInput | CommentCreateOrConnectWithoutChangeInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutChangeInput | CommentUpsertWithWhereUniqueWithoutChangeInput[]
    createMany?: CommentCreateManyChangeInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutChangeInput | CommentUpdateWithWhereUniqueWithoutChangeInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutChangeInput | CommentUpdateManyWithWhereWithoutChangeInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ChangeReviewerUncheckedUpdateManyWithoutChangeNestedInput = {
    create?: XOR<ChangeReviewerCreateWithoutChangeInput, ChangeReviewerUncheckedCreateWithoutChangeInput> | ChangeReviewerCreateWithoutChangeInput[] | ChangeReviewerUncheckedCreateWithoutChangeInput[]
    connectOrCreate?: ChangeReviewerCreateOrConnectWithoutChangeInput | ChangeReviewerCreateOrConnectWithoutChangeInput[]
    upsert?: ChangeReviewerUpsertWithWhereUniqueWithoutChangeInput | ChangeReviewerUpsertWithWhereUniqueWithoutChangeInput[]
    createMany?: ChangeReviewerCreateManyChangeInputEnvelope
    set?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    disconnect?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    delete?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    connect?: ChangeReviewerWhereUniqueInput | ChangeReviewerWhereUniqueInput[]
    update?: ChangeReviewerUpdateWithWhereUniqueWithoutChangeInput | ChangeReviewerUpdateWithWhereUniqueWithoutChangeInput[]
    updateMany?: ChangeReviewerUpdateManyWithWhereWithoutChangeInput | ChangeReviewerUpdateManyWithWhereWithoutChangeInput[]
    deleteMany?: ChangeReviewerScalarWhereInput | ChangeReviewerScalarWhereInput[]
  }

  export type ChangeCreateNestedOneWithoutReviewersInput = {
    create?: XOR<ChangeCreateWithoutReviewersInput, ChangeUncheckedCreateWithoutReviewersInput>
    connectOrCreate?: ChangeCreateOrConnectWithoutReviewersInput
    connect?: ChangeWhereUniqueInput
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type ChangeUpdateOneRequiredWithoutReviewersNestedInput = {
    create?: XOR<ChangeCreateWithoutReviewersInput, ChangeUncheckedCreateWithoutReviewersInput>
    connectOrCreate?: ChangeCreateOrConnectWithoutReviewersInput
    upsert?: ChangeUpsertWithoutReviewersInput
    connect?: ChangeWhereUniqueInput
    update?: XOR<XOR<ChangeUpdateToOneWithWhereWithoutReviewersInput, ChangeUpdateWithoutReviewersInput>, ChangeUncheckedUpdateWithoutReviewersInput>
  }

  export type ChangeCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ChangeCreateWithoutCommentsInput, ChangeUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChangeCreateOrConnectWithoutCommentsInput
    connect?: ChangeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentReactionCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentReactionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChangeUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ChangeCreateWithoutCommentsInput, ChangeUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChangeCreateOrConnectWithoutCommentsInput
    upsert?: ChangeUpsertWithoutCommentsInput
    connect?: ChangeWhereUniqueInput
    update?: XOR<XOR<ChangeUpdateToOneWithWhereWithoutCommentsInput, ChangeUpdateWithoutCommentsInput>, ChangeUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentReactionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutCommentInput | CommentReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutCommentInput | CommentReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutCommentInput | CommentReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentReactionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutCommentInput | CommentReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutCommentInput | CommentReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutCommentInput | CommentReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutReactionsInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    upsert?: CommentUpsertWithoutReactionsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutReactionsInput, CommentUpdateWithoutReactionsInput>, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type ModelCreateNestedOneWithoutDeploymentsInput = {
    create?: XOR<ModelCreateWithoutDeploymentsInput, ModelUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutDeploymentsInput
    connect?: ModelWhereUniqueInput
  }

  export type ModelVersionCreateNestedOneWithoutDeploymentsInput = {
    create?: XOR<ModelVersionCreateWithoutDeploymentsInput, ModelVersionUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: ModelVersionCreateOrConnectWithoutDeploymentsInput
    connect?: ModelVersionWhereUniqueInput
  }

  export type EnumDeploymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeploymentStatus
  }

  export type ModelUpdateOneRequiredWithoutDeploymentsNestedInput = {
    create?: XOR<ModelCreateWithoutDeploymentsInput, ModelUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutDeploymentsInput
    upsert?: ModelUpsertWithoutDeploymentsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutDeploymentsInput, ModelUpdateWithoutDeploymentsInput>, ModelUncheckedUpdateWithoutDeploymentsInput>
  }

  export type ModelVersionUpdateOneRequiredWithoutDeploymentsNestedInput = {
    create?: XOR<ModelVersionCreateWithoutDeploymentsInput, ModelVersionUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: ModelVersionCreateOrConnectWithoutDeploymentsInput
    upsert?: ModelVersionUpsertWithoutDeploymentsInput
    connect?: ModelVersionWhereUniqueInput
    update?: XOR<XOR<ModelVersionUpdateToOneWithWhereWithoutDeploymentsInput, ModelVersionUpdateWithoutDeploymentsInput>, ModelVersionUncheckedUpdateWithoutDeploymentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumModelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusFilter<$PrismaModel> | $Enums.ModelStatus
  }

  export type NestedEnumModelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelStatus | EnumModelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelStatus[] | ListEnumModelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumModelStatusWithAggregatesFilter<$PrismaModel> | $Enums.ModelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelStatusFilter<$PrismaModel>
    _max?: NestedEnumModelStatusFilter<$PrismaModel>
  }

  export type NestedEnumCollaboratorRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CollaboratorRole | EnumCollaboratorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCollaboratorRoleFilter<$PrismaModel> | $Enums.CollaboratorRole
  }

  export type NestedEnumCollaboratorRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollaboratorRole | EnumCollaboratorRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollaboratorRole[] | ListEnumCollaboratorRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCollaboratorRoleWithAggregatesFilter<$PrismaModel> | $Enums.CollaboratorRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollaboratorRoleFilter<$PrismaModel>
    _max?: NestedEnumCollaboratorRoleFilter<$PrismaModel>
  }

  export type NestedEnumVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VersionStatus | EnumVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVersionStatusFilter<$PrismaModel> | $Enums.VersionStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VersionStatus | EnumVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VersionStatus[] | ListEnumVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.VersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumVersionStatusFilter<$PrismaModel>
  }

  export type NestedEnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type NestedEnumChangeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusFilter<$PrismaModel> | $Enums.ChangeStatus
  }

  export type NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type NestedEnumChangeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeStatus | EnumChangeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeStatus[] | ListEnumChangeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChangeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeStatusFilter<$PrismaModel>
    _max?: NestedEnumChangeStatusFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDeploymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusFilter<$PrismaModel> | $Enums.DeploymentStatus
  }

  export type NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeploymentStatus | EnumDeploymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeploymentStatus[] | ListEnumDeploymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeploymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeploymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeploymentStatusFilter<$PrismaModel>
    _max?: NestedEnumDeploymentStatusFilter<$PrismaModel>
  }

  export type ModelCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ModelCollaboratorCreateNestedManyWithoutModelInput
    versions?: ModelVersionCreateNestedManyWithoutModelInput
    changes?: ChangeCreateNestedManyWithoutModelInput
    deployments?: DeploymentCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ModelCollaboratorUncheckedCreateNestedManyWithoutModelInput
    versions?: ModelVersionUncheckedCreateNestedManyWithoutModelInput
    changes?: ChangeUncheckedCreateNestedManyWithoutModelInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutOwnerInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutOwnerInput, ModelUncheckedCreateWithoutOwnerInput>
  }

  export type ModelCreateManyOwnerInputEnvelope = {
    data: ModelCreateManyOwnerInput | ModelCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ModelCollaboratorCreateWithoutUserInput = {
    id?: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutCollaboratorsInput
  }

  export type ModelCollaboratorUncheckedCreateWithoutUserInput = {
    id?: string
    modelId: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCollaboratorCreateOrConnectWithoutUserInput = {
    where: ModelCollaboratorWhereUniqueInput
    create: XOR<ModelCollaboratorCreateWithoutUserInput, ModelCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type ModelCollaboratorCreateManyUserInputEnvelope = {
    data: ModelCollaboratorCreateManyUserInput | ModelCollaboratorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChangeCreateWithoutUserInput = {
    id?: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutChangesInput
    comments?: CommentCreateNestedManyWithoutChangeInput
    reviewers?: ChangeReviewerCreateNestedManyWithoutChangeInput
  }

  export type ChangeUncheckedCreateWithoutUserInput = {
    id?: string
    modelId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChangeInput
    reviewers?: ChangeReviewerUncheckedCreateNestedManyWithoutChangeInput
  }

  export type ChangeCreateOrConnectWithoutUserInput = {
    where: ChangeWhereUniqueInput
    create: XOR<ChangeCreateWithoutUserInput, ChangeUncheckedCreateWithoutUserInput>
  }

  export type ChangeCreateManyUserInputEnvelope = {
    data: ChangeCreateManyUserInput | ChangeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    change: ChangeCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    replies?: CommentCreateNestedManyWithoutParentInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    changeId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ModelUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutOwnerInput, ModelUncheckedUpdateWithoutOwnerInput>
    create: XOR<ModelCreateWithoutOwnerInput, ModelUncheckedCreateWithoutOwnerInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutOwnerInput, ModelUncheckedUpdateWithoutOwnerInput>
  }

  export type ModelUpdateManyWithWhereWithoutOwnerInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ModelScalarWhereInput = {
    AND?: ModelScalarWhereInput | ModelScalarWhereInput[]
    OR?: ModelScalarWhereInput[]
    NOT?: ModelScalarWhereInput | ModelScalarWhereInput[]
    id?: StringFilter<"Model"> | string
    name?: StringFilter<"Model"> | string
    description?: StringNullableFilter<"Model"> | string | null
    ownerId?: StringFilter<"Model"> | string
    status?: EnumModelStatusFilter<"Model"> | $Enums.ModelStatus
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
  }

  export type ModelCollaboratorUpsertWithWhereUniqueWithoutUserInput = {
    where: ModelCollaboratorWhereUniqueInput
    update: XOR<ModelCollaboratorUpdateWithoutUserInput, ModelCollaboratorUncheckedUpdateWithoutUserInput>
    create: XOR<ModelCollaboratorCreateWithoutUserInput, ModelCollaboratorUncheckedCreateWithoutUserInput>
  }

  export type ModelCollaboratorUpdateWithWhereUniqueWithoutUserInput = {
    where: ModelCollaboratorWhereUniqueInput
    data: XOR<ModelCollaboratorUpdateWithoutUserInput, ModelCollaboratorUncheckedUpdateWithoutUserInput>
  }

  export type ModelCollaboratorUpdateManyWithWhereWithoutUserInput = {
    where: ModelCollaboratorScalarWhereInput
    data: XOR<ModelCollaboratorUpdateManyMutationInput, ModelCollaboratorUncheckedUpdateManyWithoutUserInput>
  }

  export type ModelCollaboratorScalarWhereInput = {
    AND?: ModelCollaboratorScalarWhereInput | ModelCollaboratorScalarWhereInput[]
    OR?: ModelCollaboratorScalarWhereInput[]
    NOT?: ModelCollaboratorScalarWhereInput | ModelCollaboratorScalarWhereInput[]
    id?: StringFilter<"ModelCollaborator"> | string
    modelId?: StringFilter<"ModelCollaborator"> | string
    userId?: StringFilter<"ModelCollaborator"> | string
    role?: EnumCollaboratorRoleFilter<"ModelCollaborator"> | $Enums.CollaboratorRole
    createdAt?: DateTimeFilter<"ModelCollaborator"> | Date | string
    updatedAt?: DateTimeFilter<"ModelCollaborator"> | Date | string
  }

  export type ChangeUpsertWithWhereUniqueWithoutUserInput = {
    where: ChangeWhereUniqueInput
    update: XOR<ChangeUpdateWithoutUserInput, ChangeUncheckedUpdateWithoutUserInput>
    create: XOR<ChangeCreateWithoutUserInput, ChangeUncheckedCreateWithoutUserInput>
  }

  export type ChangeUpdateWithWhereUniqueWithoutUserInput = {
    where: ChangeWhereUniqueInput
    data: XOR<ChangeUpdateWithoutUserInput, ChangeUncheckedUpdateWithoutUserInput>
  }

  export type ChangeUpdateManyWithWhereWithoutUserInput = {
    where: ChangeScalarWhereInput
    data: XOR<ChangeUpdateManyMutationInput, ChangeUncheckedUpdateManyWithoutUserInput>
  }

  export type ChangeScalarWhereInput = {
    AND?: ChangeScalarWhereInput | ChangeScalarWhereInput[]
    OR?: ChangeScalarWhereInput[]
    NOT?: ChangeScalarWhereInput | ChangeScalarWhereInput[]
    id?: StringFilter<"Change"> | string
    modelId?: StringFilter<"Change"> | string
    userId?: StringFilter<"Change"> | string
    type?: EnumChangeTypeFilter<"Change"> | $Enums.ChangeType
    content?: StringFilter<"Change"> | string
    diff?: StringNullableFilter<"Change"> | string | null
    description?: StringFilter<"Change"> | string
    status?: EnumChangeStatusFilter<"Change"> | $Enums.ChangeStatus
    createdAt?: DateTimeFilter<"Change"> | Date | string
    updatedAt?: DateTimeFilter<"Change"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    changeId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    file?: StringNullableFilter<"Comment"> | string | null
    line?: IntNullableFilter<"Comment"> | number | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentId?: StringNullableFilter<"Comment"> | string | null
  }

  export type UserCreateWithoutModelsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborations?: ModelCollaboratorCreateNestedManyWithoutUserInput
    changes?: ChangeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModelsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborations?: ModelCollaboratorUncheckedCreateNestedManyWithoutUserInput
    changes?: ChangeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModelsInput, UserUncheckedCreateWithoutModelsInput>
  }

  export type ModelCollaboratorCreateWithoutModelInput = {
    id?: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCollaborationsInput
  }

  export type ModelCollaboratorUncheckedCreateWithoutModelInput = {
    id?: string
    userId: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCollaboratorCreateOrConnectWithoutModelInput = {
    where: ModelCollaboratorWhereUniqueInput
    create: XOR<ModelCollaboratorCreateWithoutModelInput, ModelCollaboratorUncheckedCreateWithoutModelInput>
  }

  export type ModelCollaboratorCreateManyModelInputEnvelope = {
    data: ModelCollaboratorCreateManyModelInput | ModelCollaboratorCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type ModelVersionCreateWithoutModelInput = {
    id?: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deployments?: DeploymentCreateNestedManyWithoutVersionInput
  }

  export type ModelVersionUncheckedCreateWithoutModelInput = {
    id?: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deployments?: DeploymentUncheckedCreateNestedManyWithoutVersionInput
  }

  export type ModelVersionCreateOrConnectWithoutModelInput = {
    where: ModelVersionWhereUniqueInput
    create: XOR<ModelVersionCreateWithoutModelInput, ModelVersionUncheckedCreateWithoutModelInput>
  }

  export type ModelVersionCreateManyModelInputEnvelope = {
    data: ModelVersionCreateManyModelInput | ModelVersionCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type ChangeCreateWithoutModelInput = {
    id?: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChangesInput
    comments?: CommentCreateNestedManyWithoutChangeInput
    reviewers?: ChangeReviewerCreateNestedManyWithoutChangeInput
  }

  export type ChangeUncheckedCreateWithoutModelInput = {
    id?: string
    userId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChangeInput
    reviewers?: ChangeReviewerUncheckedCreateNestedManyWithoutChangeInput
  }

  export type ChangeCreateOrConnectWithoutModelInput = {
    where: ChangeWhereUniqueInput
    create: XOR<ChangeCreateWithoutModelInput, ChangeUncheckedCreateWithoutModelInput>
  }

  export type ChangeCreateManyModelInputEnvelope = {
    data: ChangeCreateManyModelInput | ChangeCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type DeploymentCreateWithoutModelInput = {
    id?: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    version: ModelVersionCreateNestedOneWithoutDeploymentsInput
  }

  export type DeploymentUncheckedCreateWithoutModelInput = {
    id?: string
    versionId: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentCreateOrConnectWithoutModelInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutModelInput, DeploymentUncheckedCreateWithoutModelInput>
  }

  export type DeploymentCreateManyModelInputEnvelope = {
    data: DeploymentCreateManyModelInput | DeploymentCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutModelsInput = {
    update: XOR<UserUpdateWithoutModelsInput, UserUncheckedUpdateWithoutModelsInput>
    create: XOR<UserCreateWithoutModelsInput, UserUncheckedCreateWithoutModelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModelsInput, UserUncheckedUpdateWithoutModelsInput>
  }

  export type UserUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborations?: ModelCollaboratorUpdateManyWithoutUserNestedInput
    changes?: ChangeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborations?: ModelCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ModelCollaboratorUpsertWithWhereUniqueWithoutModelInput = {
    where: ModelCollaboratorWhereUniqueInput
    update: XOR<ModelCollaboratorUpdateWithoutModelInput, ModelCollaboratorUncheckedUpdateWithoutModelInput>
    create: XOR<ModelCollaboratorCreateWithoutModelInput, ModelCollaboratorUncheckedCreateWithoutModelInput>
  }

  export type ModelCollaboratorUpdateWithWhereUniqueWithoutModelInput = {
    where: ModelCollaboratorWhereUniqueInput
    data: XOR<ModelCollaboratorUpdateWithoutModelInput, ModelCollaboratorUncheckedUpdateWithoutModelInput>
  }

  export type ModelCollaboratorUpdateManyWithWhereWithoutModelInput = {
    where: ModelCollaboratorScalarWhereInput
    data: XOR<ModelCollaboratorUpdateManyMutationInput, ModelCollaboratorUncheckedUpdateManyWithoutModelInput>
  }

  export type ModelVersionUpsertWithWhereUniqueWithoutModelInput = {
    where: ModelVersionWhereUniqueInput
    update: XOR<ModelVersionUpdateWithoutModelInput, ModelVersionUncheckedUpdateWithoutModelInput>
    create: XOR<ModelVersionCreateWithoutModelInput, ModelVersionUncheckedCreateWithoutModelInput>
  }

  export type ModelVersionUpdateWithWhereUniqueWithoutModelInput = {
    where: ModelVersionWhereUniqueInput
    data: XOR<ModelVersionUpdateWithoutModelInput, ModelVersionUncheckedUpdateWithoutModelInput>
  }

  export type ModelVersionUpdateManyWithWhereWithoutModelInput = {
    where: ModelVersionScalarWhereInput
    data: XOR<ModelVersionUpdateManyMutationInput, ModelVersionUncheckedUpdateManyWithoutModelInput>
  }

  export type ModelVersionScalarWhereInput = {
    AND?: ModelVersionScalarWhereInput | ModelVersionScalarWhereInput[]
    OR?: ModelVersionScalarWhereInput[]
    NOT?: ModelVersionScalarWhereInput | ModelVersionScalarWhereInput[]
    id?: StringFilter<"ModelVersion"> | string
    modelId?: StringFilter<"ModelVersion"> | string
    version?: StringFilter<"ModelVersion"> | string
    metrics?: JsonNullableFilter<"ModelVersion">
    artifacts?: JsonFilter<"ModelVersion">
    status?: EnumVersionStatusFilter<"ModelVersion"> | $Enums.VersionStatus
    createdAt?: DateTimeFilter<"ModelVersion"> | Date | string
    updatedAt?: DateTimeFilter<"ModelVersion"> | Date | string
  }

  export type ChangeUpsertWithWhereUniqueWithoutModelInput = {
    where: ChangeWhereUniqueInput
    update: XOR<ChangeUpdateWithoutModelInput, ChangeUncheckedUpdateWithoutModelInput>
    create: XOR<ChangeCreateWithoutModelInput, ChangeUncheckedCreateWithoutModelInput>
  }

  export type ChangeUpdateWithWhereUniqueWithoutModelInput = {
    where: ChangeWhereUniqueInput
    data: XOR<ChangeUpdateWithoutModelInput, ChangeUncheckedUpdateWithoutModelInput>
  }

  export type ChangeUpdateManyWithWhereWithoutModelInput = {
    where: ChangeScalarWhereInput
    data: XOR<ChangeUpdateManyMutationInput, ChangeUncheckedUpdateManyWithoutModelInput>
  }

  export type DeploymentUpsertWithWhereUniqueWithoutModelInput = {
    where: DeploymentWhereUniqueInput
    update: XOR<DeploymentUpdateWithoutModelInput, DeploymentUncheckedUpdateWithoutModelInput>
    create: XOR<DeploymentCreateWithoutModelInput, DeploymentUncheckedCreateWithoutModelInput>
  }

  export type DeploymentUpdateWithWhereUniqueWithoutModelInput = {
    where: DeploymentWhereUniqueInput
    data: XOR<DeploymentUpdateWithoutModelInput, DeploymentUncheckedUpdateWithoutModelInput>
  }

  export type DeploymentUpdateManyWithWhereWithoutModelInput = {
    where: DeploymentScalarWhereInput
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutModelInput>
  }

  export type DeploymentScalarWhereInput = {
    AND?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
    OR?: DeploymentScalarWhereInput[]
    NOT?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
    id?: StringFilter<"Deployment"> | string
    modelId?: StringFilter<"Deployment"> | string
    versionId?: StringFilter<"Deployment"> | string
    environment?: StringFilter<"Deployment"> | string
    status?: EnumDeploymentStatusFilter<"Deployment"> | $Enums.DeploymentStatus
    metrics?: JsonNullableFilter<"Deployment">
    config?: JsonFilter<"Deployment">
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
  }

  export type ModelCreateWithoutCollaboratorsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutModelsInput
    versions?: ModelVersionCreateNestedManyWithoutModelInput
    changes?: ChangeCreateNestedManyWithoutModelInput
    deployments?: DeploymentCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: ModelVersionUncheckedCreateNestedManyWithoutModelInput
    changes?: ChangeUncheckedCreateNestedManyWithoutModelInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutCollaboratorsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutCollaboratorsInput, ModelUncheckedCreateWithoutCollaboratorsInput>
  }

  export type UserCreateWithoutCollaborationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelCreateNestedManyWithoutOwnerInput
    changes?: ChangeCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCollaborationsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelUncheckedCreateNestedManyWithoutOwnerInput
    changes?: ChangeUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCollaborationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCollaborationsInput, UserUncheckedCreateWithoutCollaborationsInput>
  }

  export type ModelUpsertWithoutCollaboratorsInput = {
    update: XOR<ModelUpdateWithoutCollaboratorsInput, ModelUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<ModelCreateWithoutCollaboratorsInput, ModelUncheckedCreateWithoutCollaboratorsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutCollaboratorsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutCollaboratorsInput, ModelUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type ModelUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutModelsNestedInput
    versions?: ModelVersionUpdateManyWithoutModelNestedInput
    changes?: ChangeUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: ModelVersionUncheckedUpdateManyWithoutModelNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutModelNestedInput
  }

  export type UserUpsertWithoutCollaborationsInput = {
    update: XOR<UserUpdateWithoutCollaborationsInput, UserUncheckedUpdateWithoutCollaborationsInput>
    create: XOR<UserCreateWithoutCollaborationsInput, UserUncheckedCreateWithoutCollaborationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCollaborationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCollaborationsInput, UserUncheckedUpdateWithoutCollaborationsInput>
  }

  export type UserUpdateWithoutCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUpdateManyWithoutOwnerNestedInput
    changes?: ChangeUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCollaborationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUncheckedUpdateManyWithoutOwnerNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ModelCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutModelsInput
    collaborators?: ModelCollaboratorCreateNestedManyWithoutModelInput
    changes?: ChangeCreateNestedManyWithoutModelInput
    deployments?: DeploymentCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ModelCollaboratorUncheckedCreateNestedManyWithoutModelInput
    changes?: ChangeUncheckedCreateNestedManyWithoutModelInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutVersionsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutVersionsInput, ModelUncheckedCreateWithoutVersionsInput>
  }

  export type DeploymentCreateWithoutVersionInput = {
    id?: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutDeploymentsInput
  }

  export type DeploymentUncheckedCreateWithoutVersionInput = {
    id?: string
    modelId: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentCreateOrConnectWithoutVersionInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutVersionInput, DeploymentUncheckedCreateWithoutVersionInput>
  }

  export type DeploymentCreateManyVersionInputEnvelope = {
    data: DeploymentCreateManyVersionInput | DeploymentCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type ModelUpsertWithoutVersionsInput = {
    update: XOR<ModelUpdateWithoutVersionsInput, ModelUncheckedUpdateWithoutVersionsInput>
    create: XOR<ModelCreateWithoutVersionsInput, ModelUncheckedCreateWithoutVersionsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutVersionsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutVersionsInput, ModelUncheckedUpdateWithoutVersionsInput>
  }

  export type ModelUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutModelsNestedInput
    collaborators?: ModelCollaboratorUpdateManyWithoutModelNestedInput
    changes?: ChangeUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ModelCollaboratorUncheckedUpdateManyWithoutModelNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutModelNestedInput
  }

  export type DeploymentUpsertWithWhereUniqueWithoutVersionInput = {
    where: DeploymentWhereUniqueInput
    update: XOR<DeploymentUpdateWithoutVersionInput, DeploymentUncheckedUpdateWithoutVersionInput>
    create: XOR<DeploymentCreateWithoutVersionInput, DeploymentUncheckedCreateWithoutVersionInput>
  }

  export type DeploymentUpdateWithWhereUniqueWithoutVersionInput = {
    where: DeploymentWhereUniqueInput
    data: XOR<DeploymentUpdateWithoutVersionInput, DeploymentUncheckedUpdateWithoutVersionInput>
  }

  export type DeploymentUpdateManyWithWhereWithoutVersionInput = {
    where: DeploymentScalarWhereInput
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutVersionInput>
  }

  export type ModelCreateWithoutChangesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutModelsInput
    collaborators?: ModelCollaboratorCreateNestedManyWithoutModelInput
    versions?: ModelVersionCreateNestedManyWithoutModelInput
    deployments?: DeploymentCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutChangesInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ModelCollaboratorUncheckedCreateNestedManyWithoutModelInput
    versions?: ModelVersionUncheckedCreateNestedManyWithoutModelInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutChangesInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutChangesInput, ModelUncheckedCreateWithoutChangesInput>
  }

  export type UserCreateWithoutChangesInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelCreateNestedManyWithoutOwnerInput
    collaborations?: ModelCollaboratorCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChangesInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelUncheckedCreateNestedManyWithoutOwnerInput
    collaborations?: ModelCollaboratorUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
  }

  export type CommentCreateWithoutChangeInput = {
    id?: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    replies?: CommentCreateNestedManyWithoutParentInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutChangeInput = {
    id?: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutChangeInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChangeInput, CommentUncheckedCreateWithoutChangeInput>
  }

  export type CommentCreateManyChangeInputEnvelope = {
    data: CommentCreateManyChangeInput | CommentCreateManyChangeInput[]
    skipDuplicates?: boolean
  }

  export type ChangeReviewerCreateWithoutChangeInput = {
    id?: string
    userId: string
    status?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeReviewerUncheckedCreateWithoutChangeInput = {
    id?: string
    userId: string
    status?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeReviewerCreateOrConnectWithoutChangeInput = {
    where: ChangeReviewerWhereUniqueInput
    create: XOR<ChangeReviewerCreateWithoutChangeInput, ChangeReviewerUncheckedCreateWithoutChangeInput>
  }

  export type ChangeReviewerCreateManyChangeInputEnvelope = {
    data: ChangeReviewerCreateManyChangeInput | ChangeReviewerCreateManyChangeInput[]
    skipDuplicates?: boolean
  }

  export type ModelUpsertWithoutChangesInput = {
    update: XOR<ModelUpdateWithoutChangesInput, ModelUncheckedUpdateWithoutChangesInput>
    create: XOR<ModelCreateWithoutChangesInput, ModelUncheckedCreateWithoutChangesInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutChangesInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutChangesInput, ModelUncheckedUpdateWithoutChangesInput>
  }

  export type ModelUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutModelsNestedInput
    collaborators?: ModelCollaboratorUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ModelCollaboratorUncheckedUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUncheckedUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutModelNestedInput
  }

  export type UserUpsertWithoutChangesInput = {
    update: XOR<UserUpdateWithoutChangesInput, UserUncheckedUpdateWithoutChangesInput>
    create: XOR<UserCreateWithoutChangesInput, UserUncheckedCreateWithoutChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChangesInput, UserUncheckedUpdateWithoutChangesInput>
  }

  export type UserUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUpdateManyWithoutOwnerNestedInput
    collaborations?: ModelCollaboratorUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUncheckedUpdateManyWithoutOwnerNestedInput
    collaborations?: ModelCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutChangeInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutChangeInput, CommentUncheckedUpdateWithoutChangeInput>
    create: XOR<CommentCreateWithoutChangeInput, CommentUncheckedCreateWithoutChangeInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutChangeInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutChangeInput, CommentUncheckedUpdateWithoutChangeInput>
  }

  export type CommentUpdateManyWithWhereWithoutChangeInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutChangeInput>
  }

  export type ChangeReviewerUpsertWithWhereUniqueWithoutChangeInput = {
    where: ChangeReviewerWhereUniqueInput
    update: XOR<ChangeReviewerUpdateWithoutChangeInput, ChangeReviewerUncheckedUpdateWithoutChangeInput>
    create: XOR<ChangeReviewerCreateWithoutChangeInput, ChangeReviewerUncheckedCreateWithoutChangeInput>
  }

  export type ChangeReviewerUpdateWithWhereUniqueWithoutChangeInput = {
    where: ChangeReviewerWhereUniqueInput
    data: XOR<ChangeReviewerUpdateWithoutChangeInput, ChangeReviewerUncheckedUpdateWithoutChangeInput>
  }

  export type ChangeReviewerUpdateManyWithWhereWithoutChangeInput = {
    where: ChangeReviewerScalarWhereInput
    data: XOR<ChangeReviewerUpdateManyMutationInput, ChangeReviewerUncheckedUpdateManyWithoutChangeInput>
  }

  export type ChangeReviewerScalarWhereInput = {
    AND?: ChangeReviewerScalarWhereInput | ChangeReviewerScalarWhereInput[]
    OR?: ChangeReviewerScalarWhereInput[]
    NOT?: ChangeReviewerScalarWhereInput | ChangeReviewerScalarWhereInput[]
    id?: StringFilter<"ChangeReviewer"> | string
    changeId?: StringFilter<"ChangeReviewer"> | string
    userId?: StringFilter<"ChangeReviewer"> | string
    status?: EnumReviewStatusFilter<"ChangeReviewer"> | $Enums.ReviewStatus
    createdAt?: DateTimeFilter<"ChangeReviewer"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeReviewer"> | Date | string
  }

  export type ChangeCreateWithoutReviewersInput = {
    id?: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutChangesInput
    user: UserCreateNestedOneWithoutChangesInput
    comments?: CommentCreateNestedManyWithoutChangeInput
  }

  export type ChangeUncheckedCreateWithoutReviewersInput = {
    id?: string
    modelId: string
    userId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChangeInput
  }

  export type ChangeCreateOrConnectWithoutReviewersInput = {
    where: ChangeWhereUniqueInput
    create: XOR<ChangeCreateWithoutReviewersInput, ChangeUncheckedCreateWithoutReviewersInput>
  }

  export type ChangeUpsertWithoutReviewersInput = {
    update: XOR<ChangeUpdateWithoutReviewersInput, ChangeUncheckedUpdateWithoutReviewersInput>
    create: XOR<ChangeCreateWithoutReviewersInput, ChangeUncheckedCreateWithoutReviewersInput>
    where?: ChangeWhereInput
  }

  export type ChangeUpdateToOneWithWhereWithoutReviewersInput = {
    where?: ChangeWhereInput
    data: XOR<ChangeUpdateWithoutReviewersInput, ChangeUncheckedUpdateWithoutReviewersInput>
  }

  export type ChangeUpdateWithoutReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutChangesNestedInput
    user?: UserUpdateOneRequiredWithoutChangesNestedInput
    comments?: CommentUpdateManyWithoutChangeNestedInput
  }

  export type ChangeUncheckedUpdateWithoutReviewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChangeNestedInput
  }

  export type ChangeCreateWithoutCommentsInput = {
    id?: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutChangesInput
    user: UserCreateNestedOneWithoutChangesInput
    reviewers?: ChangeReviewerCreateNestedManyWithoutChangeInput
  }

  export type ChangeUncheckedCreateWithoutCommentsInput = {
    id?: string
    modelId: string
    userId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewers?: ChangeReviewerUncheckedCreateNestedManyWithoutChangeInput
  }

  export type ChangeCreateOrConnectWithoutCommentsInput = {
    where: ChangeWhereUniqueInput
    create: XOR<ChangeCreateWithoutCommentsInput, ChangeUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelCreateNestedManyWithoutOwnerInput
    collaborations?: ModelCollaboratorCreateNestedManyWithoutUserInput
    changes?: ChangeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    avatar?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: ModelUncheckedCreateNestedManyWithoutOwnerInput
    collaborations?: ModelCollaboratorUncheckedCreateNestedManyWithoutUserInput
    changes?: ChangeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentReactionCreateWithoutCommentInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentReactionUncheckedCreateWithoutCommentInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentReactionCreateOrConnectWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    create: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type CommentReactionCreateManyCommentInputEnvelope = {
    data: CommentReactionCreateManyCommentInput | CommentReactionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    change: ChangeCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    replies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    changeId: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    change: ChangeCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    changeId: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type ChangeUpsertWithoutCommentsInput = {
    update: XOR<ChangeUpdateWithoutCommentsInput, ChangeUncheckedUpdateWithoutCommentsInput>
    create: XOR<ChangeCreateWithoutCommentsInput, ChangeUncheckedCreateWithoutCommentsInput>
    where?: ChangeWhereInput
  }

  export type ChangeUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ChangeWhereInput
    data: XOR<ChangeUpdateWithoutCommentsInput, ChangeUncheckedUpdateWithoutCommentsInput>
  }

  export type ChangeUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutChangesNestedInput
    user?: UserUpdateOneRequiredWithoutChangesNestedInput
    reviewers?: ChangeReviewerUpdateManyWithoutChangeNestedInput
  }

  export type ChangeUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewers?: ChangeReviewerUncheckedUpdateManyWithoutChangeNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUpdateManyWithoutOwnerNestedInput
    collaborations?: ModelCollaboratorUpdateManyWithoutUserNestedInput
    changes?: ChangeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: ModelUncheckedUpdateManyWithoutOwnerNestedInput
    collaborations?: ModelCollaboratorUncheckedUpdateManyWithoutUserNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentReactionUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    update: XOR<CommentReactionUpdateWithoutCommentInput, CommentReactionUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type CommentReactionUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    data: XOR<CommentReactionUpdateWithoutCommentInput, CommentReactionUncheckedUpdateWithoutCommentInput>
  }

  export type CommentReactionUpdateManyWithWhereWithoutCommentInput = {
    where: CommentReactionScalarWhereInput
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentReactionScalarWhereInput = {
    AND?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
    OR?: CommentReactionScalarWhereInput[]
    NOT?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
    id?: StringFilter<"CommentReaction"> | string
    commentId?: StringFilter<"CommentReaction"> | string
    userId?: StringFilter<"CommentReaction"> | string
    type?: StringFilter<"CommentReaction"> | string
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    change?: ChangeUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateWithoutReactionsInput = {
    id?: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    change: ChangeCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutReactionsInput = {
    id?: string
    changeId: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutReactionsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
  }

  export type CommentUpsertWithoutReactionsInput = {
    update: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutReactionsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type CommentUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    change?: ChangeUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ModelCreateWithoutDeploymentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutModelsInput
    collaborators?: ModelCollaboratorCreateNestedManyWithoutModelInput
    versions?: ModelVersionCreateNestedManyWithoutModelInput
    changes?: ChangeCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutDeploymentsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collaborators?: ModelCollaboratorUncheckedCreateNestedManyWithoutModelInput
    versions?: ModelVersionUncheckedCreateNestedManyWithoutModelInput
    changes?: ChangeUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutDeploymentsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutDeploymentsInput, ModelUncheckedCreateWithoutDeploymentsInput>
  }

  export type ModelVersionCreateWithoutDeploymentsInput = {
    id?: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutVersionsInput
  }

  export type ModelVersionUncheckedCreateWithoutDeploymentsInput = {
    id?: string
    modelId: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelVersionCreateOrConnectWithoutDeploymentsInput = {
    where: ModelVersionWhereUniqueInput
    create: XOR<ModelVersionCreateWithoutDeploymentsInput, ModelVersionUncheckedCreateWithoutDeploymentsInput>
  }

  export type ModelUpsertWithoutDeploymentsInput = {
    update: XOR<ModelUpdateWithoutDeploymentsInput, ModelUncheckedUpdateWithoutDeploymentsInput>
    create: XOR<ModelCreateWithoutDeploymentsInput, ModelUncheckedCreateWithoutDeploymentsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutDeploymentsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutDeploymentsInput, ModelUncheckedUpdateWithoutDeploymentsInput>
  }

  export type ModelUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutModelsNestedInput
    collaborators?: ModelCollaboratorUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUpdateManyWithoutModelNestedInput
    changes?: ChangeUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ModelCollaboratorUncheckedUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUncheckedUpdateManyWithoutModelNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelVersionUpsertWithoutDeploymentsInput = {
    update: XOR<ModelVersionUpdateWithoutDeploymentsInput, ModelVersionUncheckedUpdateWithoutDeploymentsInput>
    create: XOR<ModelVersionCreateWithoutDeploymentsInput, ModelVersionUncheckedCreateWithoutDeploymentsInput>
    where?: ModelVersionWhereInput
  }

  export type ModelVersionUpdateToOneWithWhereWithoutDeploymentsInput = {
    where?: ModelVersionWhereInput
    data: XOR<ModelVersionUpdateWithoutDeploymentsInput, ModelVersionUncheckedUpdateWithoutDeploymentsInput>
  }

  export type ModelVersionUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type ModelVersionUncheckedUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.ModelStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCollaboratorCreateManyUserInput = {
    id?: string
    modelId: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeCreateManyUserInput = {
    id?: string
    modelId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    changeId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type ModelUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ModelCollaboratorUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUpdateManyWithoutModelNestedInput
    changes?: ChangeUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collaborators?: ModelCollaboratorUncheckedUpdateManyWithoutModelNestedInput
    versions?: ModelVersionUncheckedUpdateManyWithoutModelNestedInput
    changes?: ChangeUncheckedUpdateManyWithoutModelNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumModelStatusFieldUpdateOperationsInput | $Enums.ModelStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCollaboratorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutCollaboratorsNestedInput
  }

  export type ModelCollaboratorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCollaboratorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutChangesNestedInput
    comments?: CommentUpdateManyWithoutChangeNestedInput
    reviewers?: ChangeReviewerUpdateManyWithoutChangeNestedInput
  }

  export type ChangeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChangeNestedInput
    reviewers?: ChangeReviewerUncheckedUpdateManyWithoutChangeNestedInput
  }

  export type ChangeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    change?: ChangeUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModelCollaboratorCreateManyModelInput = {
    id?: string
    userId: string
    role: $Enums.CollaboratorRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelVersionCreateManyModelInput = {
    id?: string
    version: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts: JsonNullValueInput | InputJsonValue
    status?: $Enums.VersionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeCreateManyModelInput = {
    id?: string
    userId: string
    type: $Enums.ChangeType
    content: string
    diff?: string | null
    description: string
    status?: $Enums.ChangeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentCreateManyModelInput = {
    id?: string
    versionId: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelCollaboratorUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCollaborationsNestedInput
  }

  export type ModelCollaboratorUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelCollaboratorUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCollaboratorRoleFieldUpdateOperationsInput | $Enums.CollaboratorRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelVersionUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployments?: DeploymentUpdateManyWithoutVersionNestedInput
  }

  export type ModelVersionUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployments?: DeploymentUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type ModelVersionUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    artifacts?: JsonNullValueInput | InputJsonValue
    status?: EnumVersionStatusFieldUpdateOperationsInput | $Enums.VersionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChangesNestedInput
    comments?: CommentUpdateManyWithoutChangeNestedInput
    reviewers?: ChangeReviewerUpdateManyWithoutChangeNestedInput
  }

  export type ChangeUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChangeNestedInput
    reviewers?: ChangeReviewerUncheckedUpdateManyWithoutChangeNestedInput
  }

  export type ChangeUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    content?: StringFieldUpdateOperationsInput | string
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumChangeStatusFieldUpdateOperationsInput | $Enums.ChangeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: ModelVersionUpdateOneRequiredWithoutDeploymentsNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentCreateManyVersionInput = {
    id?: string
    modelId: string
    environment: string
    status?: $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeploymentUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutDeploymentsNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUncheckedUpdateManyWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    environment?: StringFieldUpdateOperationsInput | string
    status?: EnumDeploymentStatusFieldUpdateOperationsInput | $Enums.DeploymentStatus
    metrics?: NullableJsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyChangeInput = {
    id?: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type ChangeReviewerCreateManyChangeInput = {
    id?: string
    userId: string
    status?: $Enums.ReviewStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutChangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutChangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutChangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeReviewerUpdateWithoutChangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeReviewerUncheckedUpdateWithoutChangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeReviewerUncheckedUpdateManyWithoutChangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionCreateManyCommentInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    changeId: string
    userId: string
    content: string
    file?: string | null
    line?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentReactionUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    change?: ChangeUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    line?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelCountOutputTypeDefaultArgs instead
     */
    export type ModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelVersionCountOutputTypeDefaultArgs instead
     */
    export type ModelVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeCountOutputTypeDefaultArgs instead
     */
    export type ChangeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelDefaultArgs instead
     */
    export type ModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelCollaboratorDefaultArgs instead
     */
    export type ModelCollaboratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelCollaboratorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelVersionDefaultArgs instead
     */
    export type ModelVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeDefaultArgs instead
     */
    export type ChangeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeReviewerDefaultArgs instead
     */
    export type ChangeReviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeReviewerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentReactionDefaultArgs instead
     */
    export type CommentReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentReactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentDefaultArgs instead
     */
    export type DeploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}